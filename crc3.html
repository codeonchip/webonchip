<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>CRC‑3 (x^3+x+1) Calculator for 4‑Byte SPI Frame</title>
  <style>
    :root{--fg:#eaeef2;--bg:#0f172a;--muted:#94a3b8;--card:#111827;--accent:#38bdf8;--ok:#22c55e;--err:#ef4444}
    *{box-sizing:border-box}body{margin:0;font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
    header{padding:18px 20px;border-bottom:1px solid #1f2937;background:#0b1220;position:sticky;top:0}
    h1{font-size:20px;margin:0} .sub{color:var(--muted);font-size:13px}
    main{max-width:980px;margin:24px auto;padding:0 16px 40px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;padding:16px;margin:14px 0;box-shadow:0 3px 20px rgba(0,0,0,.25)}
    label{display:block;font-weight:600;margin:8px 0 6px}
    input[type="text"], select{width:100%;background:#0b1220;color:var(--fg);border:1px solid #1f2937;border-radius:10px;padding:10px 12px;font-size:15px}
    input[readonly]{opacity:.85}
    .row{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
    .row-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .hint{color:var(--muted);font-size:12px;margin-top:4px}
    .btn{display:inline-block;margin-top:10px;padding:10px 14px;border-radius:10px;border:1px solid #1f2937;background:#0b1220;color:var(--fg);cursor:pointer}
    .btn:hover{border-color:#334155}
    .kvs{display:grid;grid-template-columns:200px 1fr;gap:10px;row-gap:6px}
    code{background:#0b1220;border:1px solid #1f2937;border-radius:8px;padding:2px 6px}
    .mono{font-family: ui-monospace, Menlo, Consolas, monospace}
    .bits{display:flex;gap:8px;flex-wrap:wrap}
    .pill{padding:4px 8px;border-radius:999px;background:#0b1220;border:1px solid #1f2937}
    .ok{color:var(--ok)} .err{color:var(--err)}
    footer{color:var(--muted);font-size:12px;margin-top:16px}
  </style>
</head>
<body>
<header>
  <h1>CRC‑3 Calculator · Polynomial <span class="mono">x^3 + x + 1</span> · Seed <span class="mono">101</span></h1>
  <div class="sub">For 4‑byte SPI frames · MSB‑first or LSB‑first</div>
</header>
<main>
  <section class="card">
    <h2 style="margin:0 0 6px">TLE9180 Frame Builder (IfxTLE9180_SpiTx_bits)</h2>
    <div class="hint">Packing: [31:24] unused · [23] C · [22:16] ADDRESS(7) · [15:8] DATA(8) · [7:3] reserved(5) · [2:0] CRC3. CRC is computed over bits 31..3 (CRC excluded), MSB‑first.</div>
    <div class="row" style="margin-top:10px">
      <div>
        <label>ADDRESS (7‑bit, hex)</label>
        <input id="fldADDR" class="mono" type="text" placeholder="12" maxlength="2" value="12">
      </div>
      <div>
        <label>DATA (8‑bit, hex)</label>
        <input id="fldDATA" class="mono" type="text" placeholder="34" maxlength="2" value="34">
      </div>
      <div>
        <label>C (read/write, 0/1)</label>
        <input id="fldC" class="mono" type="text" placeholder="0" maxlength="1" value="1">
      </div>
      <div>
        <label>reserved [7:3] (5 bits, hex)</label>
        <input id="fldRSV" class="mono" type="text" placeholder="00" maxlength="2" value="00">
      </div>
    </div>
    <div class="row-2" style="margin-top:8px">
      <div>
        <label>unused [31:24] (8‑bit, hex)</label>
        <input id="fldUNU" class="mono" type="text" placeholder="00" maxlength="2" value="00">
      </div>
      <div style="align-self:end">
        <button class="btn" id="btnPackTLE">Build 4‑byte frame & compute CRC</button>
      </div>
    </div>
  </section>
  <section class="card">
    <label>Bit order on the wire</label>
    <div class="row-2">
      <select id="bitOrder">
        <option value="msb">MSB‑first (bit 31 → 0)</option>
        <option value="lsb">LSB‑first (bit 0 → 31)</option>
      </select>
      <div>
        <label class="mono">Seed</label>
        <input type="text" value="0b101 (fixed)" readonly>
      </div>
    </div>
  </section>

  <section class="card">
    <label>Enter frame data (4 bytes = 32 bits)</label>
    <div class="row">
      <div>
        <label>Byte 0</label>
        <input id="b0" class="mono" type="text" placeholder="e.g. 12" maxlength="2">
        <div class="hint">First on wire in MSB‑first</div>
      </div>
      <div>
        <label>Byte 1</label>
        <input id="b1" class="mono" type="text" placeholder="34" maxlength="2">
      </div>
      <div>
        <label>Byte 2</label>
        <input id="b2" class="mono" type="text" placeholder="56" maxlength="2">
      </div>
      <div>
        <label>Byte 3</label>
        <input id="b3" class="mono" type="text" placeholder="78" maxlength="2">
      </div>
    </div>
    <div class="row-2" style="margin-top:10px">
      <div>
        <label>Or 32‑bit word (hex)</label>
        <input id="u32" class="mono" type="text" placeholder="12345678" maxlength="8">
        <div class="hint">No <code>0x</code> prefix. Big‑endian view.</div>
      </div>
      <div style="align-self:end">
        <button class="btn" id="btnFill">Fill bytes from word</button>
        <button class="btn" id="btnWord">Build word from bytes</button>
      </div>
    </div>
  </section>

  <section class="card">
    <label>Result</label>
    <div class="kvs mono">
      <div>CRC to append (computed over bits [31..3], MSB‑first)</div>
      <div><span id="crcToAppend">—</span> <span class="hint">put this into [2:0]</span></div>

      <div>Frame's lower 3 bits [2:0]</div>
      <div class="bits"><span class="pill" id="fcrc2">—</span><span class="pill" id="fcrc1">—</span><span class="pill" id="fcrc0">—</span></div>

      <div>Frame validity (compare computed vs. [2:0])</div>
      <div id="frameOK" class="pill">—</div>

      <div>Check remainder over full 32 bits</div>
      <div><span id="checkRem">—</span> <span class="hint">For a correct frame this becomes 0 (with this seed).</span></div>

      <div>Bit stream preview (split at CRC)</div>
      <div id="bitStream" class="hint">[31..3] data  |  [2..0] CRC</div>
    </div>
  </section>

  <footer>
    Polynomial taps: x^3, x^1, x^0 · LFSR update: <code>fb = din ⊕ b2; b2' = b1; b1' = b0 ⊕ fb; b0' = fb</code> · Seed <code>0b101</code>.
  </footer>
</main>

<script>
// --- CRC‑3 (x^3 + x + 1), 3‑bit LFSR, seed 0b101 ---
function crc3Step(reg, dinBit){
  const b2 = (reg >>> 2) & 1;
  const fb = (dinBit ^ b2) & 1; // taps at x^3 and input
  const b1 = (reg >>> 1) & 1;
  const b0 = reg & 1;
  const n2 = b1;
  const n1 = b0 ^ fb; // tap at x^1
  const n0 = fb;      // tap at x^0
  return ((n2 << 2) | (n1 << 1) | n0) & 0x7;
}

function crc3WordMSB(u32){
  let reg = 0b101;
  for(let bit=31; bit>=0; --bit){
    reg = crc3Step(reg, (u32>>>bit)&1);
  }
  return reg & 7;
}
function crc3WordLSB(u32){
  let reg = 0b101;
  for(let bit=0; bit<32; ++bit){
    reg = crc3Step(reg, (u32>>>bit)&1);
  }
  return reg & 7;
}
function crc3RangeMSB(u32, hi, lo){
  let reg = 0b101;
  for(let bit=hi; bit>=lo; --bit){
    reg = crc3Step(reg, (u32>>>bit)&1);
  }
  return reg & 7;
}

// --- helpers ---
const id = s=>document.getElementById(s);
function hex2(v,len){
  return (v>>>0).toString(16).padStart(len,'0').toUpperCase();
}
function parseByte(el){
  const t = el.value.trim();
  if(!t) return null;
  const n = parseInt(t,16);
  return (Number.isFinite(n) && n>=0 && n<=255) ? n : null;
}
function parseU32(el){
  const t = el.value.trim().replace(/^0x/i,'');
  if(!t) return null;
  const n = parseInt(t,16);
  return (Number.isFinite(n) && n>=0 && n<=0xFFFFFFFF) ? n>>>0 : null;
}

function bytesToU32(b0,b1,b2,b3){
  return ((b0<<24)>>>0) | (b1<<16) | (b2<<8) | b3;
}

function refresh(){
  let b0=parseByte(id('b0')),
      b1=parseByte(id('b1')),
      b2=parseByte(id('b2')),
      b3=parseByte(id('b3'));
  let u32 = null;
  if(b0!==null && b1!==null && b2!==null && b3!==null){
    u32 = bytesToU32(b0,b1,b2,b3);
    id('u32').placeholder = hex2(u32,8);
  } else {
    u32 = parseU32(id('u32'));
    if(u32===null){
      id('crcToAppend').textContent = '—';
      ['fcrc2','fcrc1','fcrc0'].forEach(k=>id(k).textContent='—');
      id('frameOK').textContent='—'; id('frameOK').classList.remove('ok','err');
      id('checkRem').textContent='—';
      id('bitStream').textContent='[31..3] data  |  [2..0] CRC';
      return;
    }
    b0 = (u32>>>24)&255; b1=(u32>>>16)&255; b2=(u32>>>8)&255; b3=u32&255;
  }

  const order = id('bitOrder').value; // used for preview only

  // --- CRC over data‑only [31..3], MSB‑first as per TLE9180 timing ---
  const crcData = crc3RangeMSB(u32,31,3);
  id('crcToAppend').textContent = `${crcData} (0b${crcData.toString(2).padStart(3,'0')})`;

  // Frame's CRC bits currently in the word
  const fcrc = u32 & 0x7;
  id('fcrc2').textContent = (fcrc>>>2)&1; id('fcrc1').textContent=(fcrc>>>1)&1; id('fcrc0').textContent=fcrc&1;

  // Validity
  const ok = (crcData === fcrc);
  id('frameOK').textContent = ok ? 'VALID' : 'INVALID';
  id('frameOK').classList.toggle('ok', ok);
  id('frameOK').classList.toggle('err', !ok);

  // Check remainder over full 32 bits (should be 0 for a correct frame)
  const rem32 = crc3WordMSB(u32);
  id('checkRem').textContent = `${rem32}`;

  // Bit stream preview (wire order selectable for visualization only)
  const seq = (order==='msb')
    ? [...Array(32)].map((_,i)=> (u32>>> (31-i)) & 1 ).join('')
    : [...Array(32)].map((_,i)=> (u32>>> i) & 1 ).join('');
  const s = seq.slice(0,29) + ' | ' + seq.slice(29);
  id('bitStream').textContent = s;
}

// Event wiring
['b0','b1','b2','b3','u32','bitOrder'].forEach(k=>{
  id(k).addEventListener('input', refresh);
  id(k).addEventListener('change', refresh);
});

id('btnFill').addEventListener('click', ()=>{
  const w = parseU32(id('u32')); if(w===null) return;
  id('b0').value = hex2((w>>>24)&255,2);
  id('b1').value = hex2((w>>>16)&255,2);
  id('b2').value = hex2((w>>>8)&255,2);
  id('b3').value = hex2(w&255,2);
  refresh();
});

id('btnWord').addEventListener('click', ()=>{
  const b0=parseByte(id('b0')), b1=parseByte(id('b1')), b2=parseByte(id('b2')), b3=parseByte(id('b3'));
  if([b0,b1,b2,b3].some(v=>v===null)) return;
  const w = bytesToU32(b0,b1,b2,b3);
  id('u32').value = hex2(w,8);
  refresh();
});

// Initial demo values
id('b0').value='12'; id('b1').value='34'; id('b2').value='56'; id('b3').value='78';
refresh();
// --- TLE9180 frame builder helpers ---
function sanitizeHex(el, max){
  let t = el.value.trim();
  if(t==='') return null;
  t = t.replace(/^0x/i,'');
  const n = parseInt(t,16);
  if(!Number.isFinite(n)) return null;
  return (n<0?0:n>max?max:n)|0;
}
function clamp01(el){
  const t = el.value.trim();
  if(t==='') return null;
  const n = parseInt(t,10);
  if(!Number.isFinite(n)) return null;
  return n?1:0;
}
function packTLEFrame(){
  const UNU = sanitizeHex(id('fldUNU'),0xFF) ?? 0;
  const C   = clamp01(id('fldC')) ?? 0;
  const ADDR= sanitizeHex(id('fldADDR'),0x7F) ?? 0;
  const DATA= sanitizeHex(id('fldDATA'),0xFF) ?? 0;
  const RSV = sanitizeHex(id('fldRSV'),0x1F) ?? 0; // 5 bits
  // Assemble word with CRC cleared for now
  let w = 0;
  w |= (UNU & 0xFF) << 24;       // [31:24]
  w |= (C & 0x1) << 23;          // [23]
  w |= (ADDR & 0x7F) << 16;      // [22:16]
  w |= (DATA & 0xFF) << 8;       // [15:8]
  w |= (RSV & 0x1F) << 3;        // [7:3]
  // Compute CRC over bits 31..3, MSB‑first on wire
  let reg = 0b101;
  for(let bit=31; bit>=3; --bit){
    reg = crc3Step(reg, (w>>>bit)&1);
  }
  const crc = reg & 7;
  w = (w & ~0x7) | crc; // put CRC into [2:0]
  // Populate the general calculator section
  id('u32').value = hex2(w>>>0,8);
  id('b0').value = hex2((w>>>24)&255,2);
  id('b1').value = hex2((w>>>16)&255,2);
  id('b2').value = hex2((w>>>8)&255,2);
  id('b3').value = hex2(w&255,2);
  id('bitOrder').value = 'msb';
  refresh();
}

id('btnPackTLE').addEventListener('click', packTLEFrame);
</script>
</body>
</html>
