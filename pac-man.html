<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pac‑Man — Web</title>
  <style>
    :root {
      --bg: #000012;
      --maze: #132a7a;
      --maze-border: #6ea2ff;
      --dot: #ffd98a;
      --power: #fff0b3;
      --pac: #ffd800;
      --ghost-red: #ff4b5c;
      --ghost-pink: #ff99cc;
      --ghost-cyan: #00ffff;
      --ghost-orange: #ffa543;
      --ghost-scared: #3b6cff;
      --ghost-eye: #ffffff;
      --ghost-pupil: #223355;
      --ui: #eaf4ff;
      --accent: #6ea2ff;
    }
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 600px at 50% -10%, #101848, var(--bg)); color: var(--ui); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: start; padding: 16px; }
    .panel { background: #0b102d66; backdrop-filter: blur(3px); border: 1px solid #1c2b7a; border-radius: 16px; padding: 12px 14px; box-shadow: 0 10px 24px #0008; }
    .hud { grid-column: 2; display: grid; grid-template-columns: repeat(3, auto); gap: 16px; align-items: center; justify-content: center; margin-bottom: 8px; }
    .hud .btn { background: #0b1338; color: var(--ui); border: 1px solid var(--accent); padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; letter-spacing: .2px; }
    .hud .btn:active { transform: translateY(1px); }
    .hud .stat { font-weight: 700; letter-spacing: .4px; }

    .game { grid-column: 2; position: relative; }
    canvas { display: block; background: #000; border-radius: 16px; border: 2px solid #2e49a7; box-shadow: inset 0 0 40px #000, 0 20px 40px #000a; width: min(95vw, 840px); height: auto; image-rendering: pixelated; }

    .help { grid-column: 2; max-width: 840px; line-height: 1.55; }
    kbd { background: #0b1338; border: 1px solid #3a51b8; border-bottom-width: 3px; padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: .95em; }
    .lives { display: inline-flex; gap: 4px; vertical-align: middle; }
    .life { width: 14px; height: 14px; background: var(--pac); border-radius: 50%; display: inline-block; }
    .notice { color: #a8c7ff; font-size: .95rem; }
    .credits { grid-column: 2; opacity: .8; font-size: .9rem; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud panel">
      <button id="btnStart" class="btn">▶ Start</button>
      <div id="score" class="stat">Score: 0</div>
      <div id="hi" class="stat">Hi: 0</div>
      <button id="btnPause" class="btn">⏸ Pause</button>
    </div>
    <div class="game panel">
      <canvas id="game" width="560" height="640" aria-label="Pac-Man game board" role="img"></canvas>
    </div>
    <div class="help panel">
      <h2>How to play</h2>
      <p>Use <kbd>W/A/S/D</kbd> or <kbd>↑/←/↓/→</kbd> to move. Eat all dots to clear the level. Power pellets let you eat ghosts for a few seconds.</p>
      <p class="notice">Tip: You can buffer turns — press the direction slightly before you reach a junction.</p>
      <p>Controls: <kbd>P</kbd> pause, <kbd>R</kbd> restart.</p>
    </div>
    <div class="credits">
      <p>Built as a single-file HTML5 canvas game. Ghost AI uses simplified chase/scatter with unique targets per ghost, plus frightened mode on power pellets. Data persists high score via <code>localStorage</code>.</p>
    </div>
  </div>

  <script>
  // --- Game constants ------------------------------------------------------
  const TILE = 20;              // tile size in pixels (board is 28x32 tiles)
  const COLS = 28, ROWS = 32;   // classic-ish proportions
  const SPEED = 0.9;            // base Pac speed (tiles/sec)
  const GHOST_SPEED = 0.85;     // base ghost speed
  const FRIGHT_SPEED = 0.7;     // ghost speed when frightened
  const TUNNEL_SPEED = 0.6;     // slower in tunnel
  const POWER_TIME = 6.0;       // frightened duration (seconds)
  const SCATTER_TIME = 7.0;     // scatter mode duration
  const CHASE_TIME = 20.0;      // chase mode duration
  const DOT_SCORE = 10, PWR_SCORE = 50, GHOST_SCORE_BASE = 200;

  // Maze legend: 0 empty, 1 wall, 2 dot, 3 power pellet, 4 gate, 5 tunnel
  // Slightly adapted layout to fit 28x32.
  const MAZE = [
    "1111111111111111111111111111",
    "1222222222111222222222222221",
    "1211112112111211112111111121",
    "1311112112111211112111111131",
    "1211112112111211112111111121",
    "1222222222222222222222222221",
    "1211112112111211112111111121",
    "1211112112111211112111111121",
    "1222222222111222222222222221",
    "1111112111111111111112111111",
    "1111112111111111111112111111",
    "1222222222114422222222222221",
    "1211112112111111211211111121",
    "1211112112111111211211111121",
    "1222222222333322222222222221",
    "1111112111111111111112111111",
    "1111112111111111111112111111",
    "1222222222111222222222222221",
    "1211112112111211112111111121",
    "1211112112111211112111111121",
    "1222222222222222222222222221",
    "1111111111111111111111111111",
    "1000000000000550000000000001",
    "1222222222222222222222222221",
    "1211112112111211112111111121",
    "1311112112111211112111111131",
    "1211112112111211112111111121",
    "1222222222111222222222222221",
    "1111112111111111111112111111",
    "1111112111111111111112111111",
    "1222222222222222222222222221",
    "1111111111111111111111111111",
  ].map(r => r.split('').map(n => +n));

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');

  let hiScore = +localStorage.getItem('pac_hi') || 0;
  hiEl.textContent = `Hi: ${hiScore}`;

  // --- Utilities -----------------------------------------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const tileAt = (x, y) => MAZE[y]?.[x] ?? 1;
  const isWall = (x, y) => tileAt(x, y) === 1 || tileAt(x, y) === 4;
  const canMove = (tx, ty) => !isWall(tx, ty);
  const inTunnel = (tx, ty) => tileAt(tx, ty) === 5;
  const centerOf = (tx, ty) => ({ x: tx * TILE + TILE/2, y: ty * TILE + TILE/2 });
  const dist2 = (a, b) => (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);
  const rand = (a,b) => a + Math.random()*(b-a);

  function findDotsLeft(){
    let c=0; for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(MAZE[y][x]===2||MAZE[y][x]===3)c++; return c;
  }

  // --- Entities ------------------------------------------------------------
  const DIRS = { up:[0,-1], left:[-1,0], down:[0,1], right:[1,0] };
  const DIR_KEYS = { 'ArrowUp':'up','KeyW':'up','ArrowLeft':'left','KeyA':'left','ArrowDown':'down','KeyS':'down','ArrowRight':'right','KeyD':'right' };

  function makeActor(x, y, speed){
    return { x, y, dir:'left', nextDir:null, speed, dead:false };
  }

  let pac, ghosts, state;
  let score=0, lives=3, dotsLeft=findDotsLeft();
  let frightened=0, ghostCombo=0;
  let mode='scatter', modeTimer=SCATTER_TIME;
  let paused=false, running=false;

  function resetActors(){
    pac = makeActor(14.5*TILE, 23.5*TILE, SPEED);
    pac.dir='left'; pac.nextDir=null;
    ghosts = [
      { ...makeActor(14.5*TILE, 15.5*TILE, GHOST_SPEED), color: getComputedStyle(document.documentElement).getPropertyValue('--ghost-red').trim(), name:'blinky', home:{x:COLS-2, y:1} },
      { ...makeActor(13.5*TILE, 17.5*TILE, GHOST_SPEED*0.98), color: getComputedStyle(document.documentElement).getPropertyValue('--ghost-pink').trim(), name:'pinky', home:{x:1, y:1} },
      { ...makeActor(14.5*TILE, 17.5*TILE, GHOST_SPEED*0.97), color: getComputedStyle(document.documentElement).getPropertyValue('--ghost-cyan').trim(), name:'inky', home:{x:COLS-2, y:ROWS-2} },
      { ...makeActor(15.5*TILE, 17.5*TILE, GHOST_SPEED*0.96), color: getComputedStyle(document.documentElement).getPropertyValue('--ghost-orange').trim(), name:'clyde', home:{x:1, y:ROWS-2} },
    ];
  }

  function newGame(){
    // Reset maze dots/pellets (rebuild from template 2/3 values)
    const TEMPLATE = MAZE.map(r=>r.slice());
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(TEMPLATE[y][x]===0) MAZE[y][x]=0; else if(TEMPLATE[y][x]===1||TEMPLATE[y][x]===4||TEMPLATE[y][x]===5) MAZE[y][x]=TEMPLATE[y][x]; else MAZE[y][x]=TEMPLATE[y][x]>=3?3:2;
    score=0; lives=3; frightened=0; ghostCombo=0; mode='scatter'; modeTimer=SCATTER_TIME; paused=false; running=true;
    dotsLeft=findDotsLeft();
    resetActors();
    scoreEl.textContent = `Score: ${score}`;
  }

  function loseLife(){
    lives--; if(lives<0){ gameOver(); return; }
    frightened=0; ghostCombo=0; mode='scatter'; modeTimer=SCATTER_TIME;
    resetActors();
  }

  function gameOver(){ running=false; draw(); banner("GAME OVER — Press R to restart"); }

  // --- Input ---------------------------------------------------------------
  window.addEventListener('keydown', (e)=>{
    if(e.code==='KeyP'){ paused=!paused; return; }
    if(e.code==='KeyR'){ newGame(); return; }
    const d = DIR_KEYS[e.code]; if(d){ pac.nextDir=d; e.preventDefault(); }
  });

  btnStart.addEventListener('click', ()=>{ newGame(); });
  btnPause.addEventListener('click', ()=>{ paused=!paused; });

  // --- Movement & AI -------------------------------------------------------
  function gridPos(actor){ return { tx: Math.round(actor.x / TILE - 0.5), ty: Math.round(actor.y / TILE - 0.5) }; }
  function atCenter(actor){ const {tx,ty}=gridPos(actor); const c=centerOf(tx,ty); return Math.abs(actor.x-c.x)<0.1 && Math.abs(actor.y-c.y)<0.1; }

  function tryTurn(actor, dir){
    const {tx,ty} = gridPos(actor);
    const [dx,dy] = DIRS[dir];
    const nx = tx + dx, ny = ty + dy;
    if(canMove(nx, ny)) { actor.dir = dir; return true; }
    return false;
  }

  function stepActor(actor, dt){
    const speed = actor===pac ? actor.speed : (frightened>0 ? FRIGHT_SPEED : actor.speed) * (inTunnel(...Object.values(gridPos(actor)))?TUNNEL_SPEED:1);
    const [dx,dy] = DIRS[actor.dir];
    actor.x += dx * TILE * speed * dt;
    actor.y += dy * TILE * speed * dt;

    // wrap tunnels
    if(actor.x < -TILE) actor.x = (COLS+0.5)*TILE;
    if(actor.x > (COLS+1)*TILE) actor.x = -0.5*TILE;
  }

  function stepPac(dt){
    if(pac.nextDir && atCenter(pac)) tryTurn(pac, pac.nextDir);
    // If blocked, stop at center
    const {tx,ty}=gridPos(pac); const [dx,dy]=DIRS[pac.dir];
    if(!canMove(tx+dx, ty+dy) && atCenter(pac)) return; // wait at junction
    stepActor(pac, dt);

    // Eat dot/pellet
    const ttx=Math.round(pac.x/TILE-0.5), tty=Math.round(pac.y/TILE-0.5);
    const cell = MAZE[tty]?.[ttx];
    if(cell===2){ MAZE[tty][ttx]=0; score+=DOT_SCORE; dotsLeft--; }
    if(cell===3){ MAZE[tty][ttx]=0; score+=PWR_SCORE; frightened=POWER_TIME; ghostCombo=0; dotsLeft--; mode='chase'; modeTimer=CHASE_TIME*0.5; }
    scoreEl.textContent = `Score: ${score}`;
    if(score>hiScore){ hiScore=score; localStorage.setItem('pac_hi', hiScore); hiEl.textContent = `Hi: ${hiScore}`; }
    if(dotsLeft<=0){ nextLevel(); }
  }

  function nextLevel(){
    // Refill dots, keep score & lives, speed up slightly
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(MAZE[y][x]===0){ /* leave empty */ } else if(MAZE[y][x]!==1 && MAZE[y][x]!==4 && MAZE[y][x]!==5){ MAZE[y][x] = (Math.random()<0.03)?3:2; }
    pac.speed = clamp(pac.speed + 0.05, 0, 1.3);
    ghosts.forEach(g=>g.speed=clamp(g.speed+0.03,0,1.2));
    frightened = 0; ghostCombo=0; mode='scatter'; modeTimer=SCATTER_TIME; dotsLeft=findDotsLeft();
    resetActors();
  }

  function ghostTarget(g){
    const p = gridPos(pac);
    if(mode==='scatter') return g.home;
    // chase targets per ghost (simplified classic behaviors)
    switch(g.name){
      case 'blinky': return {x:p.tx, y:p.ty}; // direct chase
      case 'pinky': {
        const [dx,dy]=DIRS[pac.dir]; return {x:p.tx+2*dx, y:p.ty+2*dy};
      }
      case 'inky': {
        const [dx,dy]=DIRS[pac.dir]; const fx=p.tx+dx, fy=p.ty+dy; const b=gridPos(ghosts[0]); // blinky pos
        return { x: fx + (fx - b.tx), y: fy + (fy - b.ty) };
      }
      case 'clyde': {
        const d2 = (g.x/TILE - pac.x/TILE)**2 + (g.y/TILE - pac.y/TILE)**2;
        return d2 < 64 ? g.home : {x:p.tx, y:p.ty};
      }
    }
  }

  function stepGhost(g, dt){
    // choose direction only at centers
    if(atCenter(g)){
      const {tx,ty}=gridPos(g);
      const options = [];
      for(const [dir,[dx,dy]] of Object.entries(DIRS)){
        const ox=tx+dx, oy=ty+dy;
        if(canMove(ox,oy)){
          // avoid reversing unless necessary
          const rev = (dir==='up'&&g.dir==='down')||(dir==='down'&&g.dir==='up')||(dir==='left'&&g.dir==='right')||(dir==='right'&&g.dir==='left');
          if(rev) continue;
          options.push(dir);
        }
      }
      if(options.length===0){ /* must reverse */
        const revMap={up:'down',down:'up',left:'right',right:'left'}; g.dir=revMap[g.dir];
      } else {
        if(frightened>0){
          g.dir = options[Math.floor(Math.random()*options.length)];
        } else {
          // pick option that minimizes distance to target
          const tgt = ghostTarget(g);
          let best=null, bestD=1e9;
          for(const dir of options){
            const [dx,dy]=DIRS[dir]; const cx=tx+dx, cy=ty+dy; const c=centerOf(cx,cy);
            const d = (c.x - (tgt.x*TILE+TILE/2))**2 + (c.y - (tgt.y*TILE+TILE/2))**2;
            if(d<bestD){ bestD=d; best=dir; }
          }
          g.dir = best || options[0];
        }
      }
    }
    stepActor(g, dt);
  }

  function checkCollisions(){
    for(const g of ghosts){
      const d2 = dist2(pac, g);
      if(d2 < (TILE*0.6)*(TILE*0.6)){
        if(frightened>0){ // eat ghost
          ghostCombo++; score += GHOST_SCORE_BASE * (1<<Math.min(ghostCombo-1,3));
          // send ghost to house center and make them recover
          g.x = 14.5*TILE; g.y = 16.5*TILE; g.dir='up';
          scoreEl.textContent = `Score: ${score}`;
        } else {
          loseLife(); break;
        }
      }
    }
  }

  // --- Draw ---------------------------------------------------------------
  function drawMaze(){
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        const v = MAZE[y][x];
        const px = x*TILE, py = y*TILE;
        if(v===1 || v===4){ // walls & gate
          ctx.fillStyle = v===4 ? '#8fb3ff' : getComputedStyle(document.documentElement).getPropertyValue('--maze');
          ctx.fillRect(px, py, TILE, TILE);
          // border glow
          ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--maze-border');
          ctx.lineWidth = 2; ctx.strokeRect(px+1, py+1, TILE-2, TILE-2);
        } else if(v===2){ // dot
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dot');
          ctx.beginPath(); ctx.arc(px+TILE/2, py+TILE/2, 2, 0, Math.PI*2); ctx.fill();
        } else if(v===3){ // power pellet
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--power');
          const pulse = 3 + 1.5*Math.sin(perf*6);
          ctx.beginPath(); ctx.arc(px+TILE/2, py+TILE/2, pulse, 0, Math.PI*2); ctx.fill();
        }
      }
    }
  }

  function drawPac(){
    const mouth = 0.25 + 0.15*Math.sin(perf*10);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pac');
    ctx.beginPath();
    ctx.moveTo(pac.x, pac.y);
    const dirAng = {right:0,down:Math.PI/2,left:Math.PI,up:-Math.PI/2}[pac.dir];
    ctx.arc(pac.x, pac.y, TILE*0.45, dirAng+mouth, dirAng+Math.PI*2-mouth);
    ctx.closePath(); ctx.fill();
  }

  function drawGhost(g){
    const color = frightened>0 ? getComputedStyle(document.documentElement).getPropertyValue('--ghost-scared') : g.color;
    const w=TILE*0.9, h=TILE*0.9; const x=g.x-w/2, y=g.y-h/2;
    // body
    ctx.fillStyle=color; ctx.beginPath();
    ctx.moveTo(x, y+h*0.6);
    ctx.quadraticCurveTo(x, y, x+w*0.5, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+h*0.6);
    // skirt
    const fringes=4; for(let i=0;i<=fringes;i++){ const fx=x+w*(i/fringes); const fy=y+h*0.6 + (i%2? h*0.3: h*0.2); ctx.lineTo(fx, fy); }
    ctx.closePath(); ctx.fill();
    // eyes
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ghost-eye');
    const eox = {left:-1,right:1,up:0,down:0}[g.dir];
    const eoy = {left:0,right:0,up:-1,down:1}[g.dir];
    for(const ex of [-w*0.2, w*0.2]){
      ctx.beginPath(); ctx.ellipse(g.x+ex*0.6, y+h*0.35, w*0.12, w*0.16, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ghost-pupil');
      ctx.beginPath(); ctx.arc(g.x+ex*0.6 + eox*3, y+h*0.35 + eoy*3, w*0.05, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ghost-eye');
    }
  }

  function drawHUD(){
    // Lives icons
    const livesX = 8, livesY = canvas.height - 18;
    for(let i=0;i<lives;i++){
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pac');
      ctx.beginPath(); ctx.arc(livesX + i*16, livesY, 6, 0, Math.PI*2); ctx.fill();
    }
  }

  function banner(text){
    ctx.save();
    ctx.fillStyle = '#0008'; ctx.fillRect(0, canvas.height/2 - 40, canvas.width, 80);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 22px system-ui,Segoe UI,Roboto'; ctx.textAlign='center'; ctx.fillText(text, canvas.width/2, canvas.height/2+8);
    ctx.restore();
  }

  // --- Main loop -----------------------------------------------------------
  let last=0, perf=0;
  function tick(t){
    requestAnimationFrame(tick);
    const now = t/1000; const dt = Math.min(0.033, now-last || 0); last=now; perf=now;
    if(!running || paused){ draw(); if(!running) banner('Press Start or R'); if(paused) banner('Paused'); return; }

    // timers
    if(frightened>0){ frightened -= dt; if(frightened<0) frightened=0; }
    modeTimer -= dt; if(modeTimer<=0){ if(mode==='scatter'){ mode='chase'; modeTimer=CHASE_TIME; } else { mode='scatter'; modeTimer=SCATTER_TIME; } }

    stepPac(dt);
    ghosts.forEach(g=>stepGhost(g, dt));
    checkCollisions();
    draw();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawMaze();
    drawPac();
    ghosts.forEach(drawGhost);
    drawHUD();
  }

  resetActors();
  draw();
  requestAnimationFrame(tick);
  </script>
</body>
</html>
