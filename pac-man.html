<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple Pac‑Man</title>
<style>
  :root{--bg:#0b0d17;--maze:#0b39ff;--text:#e7e9ff;--pill:#ffd166;--pac:#ffcf00;--ghost:#ff4d6d}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 20%, #101327, #06070c);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;color:var(--text)}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:8px}
  #ui{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  .badge{background:#11143a;border:1px solid #1d2260;border-radius:10px;padding:6px 10px;font-weight:600}
  button{appearance:none;border:1px solid #2a2f7a;background:#141953;color:#d9ddff;border-radius:10px;padding:8px 12px;cursor:pointer}
  button:hover{filter:brightness(1.1)}
  canvas{background:#000;border:4px solid #0b39ff;border-radius:10px;box-shadow:0 0 0 2px #0b39ff44, 0 12px 40px #0008}
  .hint{opacity:.7;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div id="ui">
    <div class="badge">Score: <span id="score">0</span></div>
    <div class="badge">Lives: <span id="lives">3</span></div>
    <button id="restart">Restart</button>
  </div>
  <canvas id="game" width="456" height="552" aria-label="Pac-Man game" role="img"></canvas>
  <div class="hint">Arrows / WASD to move. Eat all dots. Avoid the ghost!</div>
</div>
<script>
// --- Simple Pac‑Man (single ghost, dots, wrap tunnel) ---
(function(){
  const tile = 24;                  // tile size in pixels
  const cols = 19, rows = 23;       // board size (fits 456x552)
  const W = cols*tile, H = rows*tile;
  const canvas = document.getElementById('game');
  const c = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const restartBtn = document.getElementById('restart');

  // Tile types
  const T = { EMPTY:0, WALL:1, DOT:2, POWER:3, GATE:4 };

  // Simple maze (0 empty, 1 wall, 2 dot, 4 ghost gate). Designed symmetric-ish
  const M = [
    '1111111111111111111',
    '1222222211222222221',
    '1211111211211111121',
    '1311111211211111131',
    '1211111211211111121',
    '1222222222222222221',
    '1211111211111211121',
    '1222222211222222221',
    '1111111211211111111',
    '0000011211211000000',
    '1111011222221011111',
    '1111011214411011111',
    '1111011211111011111',
    '0000011222221000000',
    '1111111211211111111',
    '1222222211222222221',
    '1211111211111211121',
    '1222222222222222221',
    '1211111211211111121',
    '1311111211211111131',
    '1211111211211111121',
    '1222222211222222221',
    '1111111111111111111',
  ].map(row=>row.split('').map(n=>+n));

  // Replace 0 with empty (space) and 2/3 dots everywhere not walls/gate
  for (let r=0;r<rows;r++) for (let c2=0;c2<cols;c2++) {
    if (M[r][c2]===0) M[r][c2]=0; // outside space
    if (M[r][c2]===2) M[r][c2]=T.DOT;
    if (M[r][c2]===3) M[r][c2]=T.POWER; // big dot (not used for fright, just 5 pts)
    if (M[r][c2]===4) M[r][c2]=T.GATE;  // ghost door
    if (M[r][c2]===1) M[r][c2]=T.WALL;
  }

  // Helpers
  const within = (r,c)=> r>=0&&r<rows&&c>=0&&c<cols;
  const isWallish = (r,c)=> within(r,c) && (M[r][c]===T.WALL || M[r][c]===T.GATE);

  // Place dots where empty inside maze paths (already in map)

  // Entities
  const pac = { r: 13, c: 9, x: 9*tile+tile/2, y: 13*tile+tile/2, dir:{x:0,y:0}, next:{x:0,y:0}, speed: 3, mouth:0, mouthDir:1 };
  const ghost = { r: 11, c: 9, x: 9*tile+tile/2, y: 11*tile+tile/2, dir:{x:0,y:0}, speed: 2.5, scatterTimer: 0 };

  let score = 0; let lives = 3; let running = true; let won=false; let then=0;

  function resetRound(){
    pac.r=13; pac.c=9; pac.x=9*tile+tile/2; pac.y=13*tile+tile/2; pac.dir={x:0,y:0}; pac.next={x:0,y:0};
    ghost.r=11; ghost.c=9; ghost.x=9*tile+tile/2; ghost.y=11*tile+tile/2; ghost.dir={x:0,y:0}; ghost.scatterTimer=90;
  }

  function restartGame(){
    // rebuild dots
    for (let r=0;r<rows;r++) for (let c2=0;c2<cols;c2++) if (M[r][c2]!==T.WALL && M[r][c2]!==T.GATE && M[r][c2]!==0) {
      if (M[r][c2]===T.EMPTY) M[r][c2]=T.DOT;
    }
    // But our map already has DOT/POWER marked; nothing to reset except eaten ones -> re-add
    for (let r=0;r<rows;r++) for (let c2=0;c2<cols;c2++) {
      if (M[r][c2]===T.EMPTY) M[r][c2]=T.DOT; // simple refill
    }
    // Keep walls, gates, outside zeros
    score=0; lives=3; running=true; won=false; scoreEl.textContent=score; livesEl.textContent=lives; resetRound();
  }

  restartBtn.addEventListener('click', restartGame);

  // Input
  const dirs = { ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
                 w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0} };
  addEventListener('keydown', e=>{
    if (!running) { if (e.key==='Enter') restartGame(); return; }
    const d = dirs[e.key]; if (!d) return; pac.next=d;
  });

  function atCenter(entity){
    const cx = Math.round((entity.x - tile/2)/tile)*tile + tile/2;
    const cy = Math.round((entity.y - tile/2)/tile)*tile + tile/2;
    return Math.abs(entity.x - cx) < 0.5 && Math.abs(entity.y - cy) < 0.5;
  }
  function cellFromPos(x,y){ return { c: Math.floor(x/tile), r: Math.floor(y/tile) }; }

  function canMove(r,c,dx,dy){
    const nr=r+dy, nc=c+dx;
    if (nc<0) return true; // wrap
    if (nc>=cols) return true;
    return !isWallish(nr,nc);
  }

  function stepEntity(ent){
    // Handle wrap tunnels horizontally
    if (ent.x < -1) { ent.x = W + tile/2 - 1; ent.c = cols-1; }
    if (ent.x > W + 1) { ent.x = -tile/2 + 1; ent.c = 0; }

    // At center -> update grid indices
    const pos = cellFromPos(ent.x, ent.y); ent.c = pos.c; ent.r = pos.r;

    if (ent===pac) {
      // Try to turn if possible at centers
      if (atCenter(pac)) {
        if (pac.next.x!==pac.dir.x || pac.next.y!==pac.dir.y) {
          if (canMove(pac.r, pac.c, pac.next.x, pac.next.y)) pac.dir = {...pac.next};
        }
      }
      // Prevent moving into walls
      if (atCenter(pac) && !canMove(pac.r, pac.c, pac.dir.x, pac.dir.y)) pac.dir={x:0,y:0};

      // Move
      pac.x += pac.dir.x * pac.speed; pac.y += pac.dir.y * pac.speed;

      // Eat dots
      if (atCenter(pac)) {
        const r=pac.r,c2=pac.c; if (within(r,c2)) {
          if (M[r][c2]===T.DOT){ M[r][c2]=T.EMPTY; score+=10; scoreEl.textContent=score; }
          else if (M[r][c2]===T.POWER){ M[r][c2]=T.EMPTY; score+=50; scoreEl.textContent=score; }
        }
      }
      // Mouth animation
      pac.mouth += pac.mouthDir*0.15; if (pac.mouth>0.7||pac.mouth<0) pac.mouthDir*=-1;
    } else {
      // Ghost logic: at center, choose direction (simple chase + random)
      if (atCenter(ent)) {
        const choices = [];
        const opts = [ {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1} ];
        for (const o of opts){ if (canMove(ent.r, ent.c, o.x, o.y) && !(o.x===-ent.dir.x && o.y===-ent.dir.y)) choices.push(o); }
        // bias toward Pac-Man occasionally
        let best = ent.dir; let bestDist = 1e9;
        for (const ch of choices){
          const rr = ent.r + ch.y, cc = ent.c + ch.x;
          const d = (rr-pac.r)**2 + (cc-pac.c)**2;
          if (d < bestDist){ bestDist = d; best = ch; }
        }
        ent.dir = (Math.random()<0.75 && choices.length)? best : (choices[Math.floor(Math.random()*choices.length)] || ent.dir);
      }
      // Prevent walls
      if (atCenter(ent) && !canMove(ent.r, ent.c, ent.dir.x, ent.dir.y)) ent.dir = {x:0,y:0};
      ent.x += ent.dir.x * ent.speed; ent.y += ent.dir.y * ent.speed;
    }
  }

  function checkCollisions(){
    const dx = pac.x - ghost.x, dy = pac.y - ghost.y; const d2 = dx*dx+dy*dy;
    if (d2 < (tile*0.6)*(tile*0.6)) {
      lives--; livesEl.textContent=lives; if (lives<=0){ running=false; }
      resetRound();
    }
  }

  function remainingDots(){
    let n=0; for (let r=0;r<rows;r++) for (let c2=0;c2<cols;c2++) if (M[r][c2]===T.DOT||M[r][c2]===T.POWER) n++; return n;
  }

  function drawMaze(){
    c.clearRect(0,0,W,H);
    // background
    c.fillStyle = '#000'; c.fillRect(0,0,W,H);
    // walls
    c.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--maze');
    c.lineWidth = 4; c.lineCap='round';
    for (let r=0;r<rows;r++) for (let cc2=0;cc2<cols;cc2++) {
      const t=M[r][cc2];
      const x=cc2*tile, y=r*tile;
      if (t===T.WALL){ c.strokeRect(x+2,y+2,tile-4,tile-4); }
      if (t===T.GATE){ c.strokeStyle = '#9aa3ff'; c.beginPath(); c.moveTo(x+4,y+tile/2); c.lineTo(x+tile-4,y+tile/2); c.stroke(); c.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--maze'); }
      if (t===T.DOT){ c.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pill'); c.beginPath(); c.arc(x+tile/2,y+tile/2,3,0,Math.PI*2); c.fill(); }
      if (t===T.POWER){ c.fillStyle = '#ffe08a'; c.beginPath(); c.arc(x+tile/2,y+tile/2,6,0,Math.PI*2); c.fill(); }
    }
  }

  function drawPac(){
    const angleOpen = Math.abs(pac.mouth) * 0.8; // radians
    const dir = (pac.dir.x===1?0: pac.dir.x===-1?Math.PI: pac.dir.y===-1?1.5*Math.PI: pac.dir.y===1?0.5*Math.PI: 0);
    c.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pac');
    c.beginPath();
    c.moveTo(pac.x, pac.y);
    c.arc(pac.x, pac.y, 9, dir+angleOpen, dir-angleOpen, true);
    c.closePath();
    c.fill();
    // eye
    c.fillStyle = '#1b1b1b';
    c.beginPath();
    c.arc(pac.x + (pac.dir.x===0?3:0) + (pac.dir.x===-1?-3: (pac.dir.x===1?3:0)), pac.y-4, 1.5, 0, Math.PI*2); c.fill();
  }

  function drawGhost(){
    const x=ghost.x, y=ghost.y; const r=9; c.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--ghost');
    c.beginPath(); c.arc(x,y,r,Math.PI,0); c.rect(x-r,y,x+r-(x-r),r); // body
    c.fill();
    // eyes
    c.fillStyle='#fff'; c.beginPath(); c.arc(x-4,y-3,2.3,0,Math.PI*2); c.arc(x+4,y-3,2.3,0,Math.PI*2); c.fill();
    c.fillStyle='#1133ff'; c.beginPath(); c.arc(x-4+ghost.dir.x*1.2,y-3+ghost.dir.y*1.2,1.3,0,Math.PI*2); c.arc(x+4+ghost.dir.x*1.2,y-3+ghost.dir.y*1.2,1.3,0,Math.PI*2); c.fill();
  }

  function message(txt){
    c.fillStyle='rgba(0,0,0,.5)'; c.fillRect(0,H/2-24,W,48);
    c.fillStyle='#fff'; c.font='700 20px system-ui,Segoe UI,Roboto'; c.textAlign='center'; c.fillText(txt, W/2,H/2+6);
  }

  function loop(now){
    const dt=(now-then)/16.6667; then=now; if (!running && !won){ drawMaze(); drawPac(); drawGhost(); message('Game Over — Press Enter to Restart'); requestAnimationFrame(loop); return; }
    if (won){ drawMaze(); drawPac(); drawGhost(); message('You Win! — Press Enter to Restart'); requestAnimationFrame(loop); return; }

    stepEntity(pac); stepEntity(ghost);
    checkCollisions();

    if (remainingDots()===0){ won=true; running=false; }

    drawMaze(); drawPac(); drawGhost();

    requestAnimationFrame(loop);
  }

  // Initialize: remove dots where walls/outside; ensure paths have dots
  for (let r=0;r<rows;r++) for (let c2=0;c2<cols;c2++) if (M[r][c2]!==T.WALL && M[r][c2]!==T.GATE && M[r][c2]!==0) {
    if (M[r][c2]!==T.DOT && M[r][c2]!==T.POWER) M[r][c2]=T.DOT;
  }

  resetRound();
  requestAnimationFrame(t=>{ then=t; loop(t); });

  // Allow Enter to restart when over
  addEventListener('keydown', e=>{ if ((e.key==='Enter'||e.key===' ') && (!running||won)) { restartGame(); } });
})();
</script>
</body>
</html>
