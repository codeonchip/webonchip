<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>3D Function Grapher (z = f(x, y))</title>
<style>
  :root { --bg:#0f172a; --panel:#0b1020; --fg:#e2e8f0; --muted:#94a3b8; --accent:#38bdf8; --line:#1e293b; }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--fg)}
  header{padding:14px 16px;border-bottom:1px solid #0b1220;background:var(--panel);position:sticky;top:0;z-index:2}
  h1{margin:0 0 6px;font-size:18px;color:#e5f3ff}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  input,select,button,textarea{background:#0b1220;color:var(--fg);border:1px solid var(--line);border-radius:10px;padding:8px 10px;font-size:14px}
  input:focus,select:focus,textarea:focus{outline:2px solid #124d74;border-color:#0ea5e9}
  button{cursor:pointer;background:#0ea5e9;border-color:#0ea5e9;color:#071422;font-weight:600}
  button.secondary{background:transparent;border-color:#334155;color:#cbd5e1}
  main{display:grid;grid-template-columns:360px 1fr;min-height:calc(100dvh - 72px)}
  aside{border-right:1px solid #0b1220;padding:14px}
  .group{margin-bottom:12px}
  .hint{font-size:12px;color:#9fb3c8;line-height:1.35}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  textarea{width:100%;min-height:88px;resize:vertical;line-height:1.4}
  #errors{color:#fca5a5;white-space:pre-wrap;font-size:12px;min-height:1.2em}
  #panel{display:grid;grid-template-rows: 1fr auto}
  canvas{width:100%;height:100%;display:block;background:#060b16}
  footer{padding:10px 14px;border-top:1px solid #0b1220;color:#8daac1;font-size:12px}
  .toggle{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label.chk{display:flex;align-items:center;gap:6px;font-size:13px;color:#cdd9e5}
  code.kbd{padding:0 6px;border:1px solid #334155;border-radius:6px;font-size:12px;color:#a8c5db}
  @media (max-width:1000px){ main{grid-template-columns:1fr} aside{border-right:none;border-bottom:1px solid #0b1220} }
</style>
</head>
<body>
<header>
  <h1>3D Function Grapher — z = f(x, y)</h1>
  <div class="row">
    <select id="preset">
      <option value="">Presets…</option>
      <option>sin(r)/r</option>
      <option>sin(x)*cos(y)</option>
      <option>0.2*(x^2 - y^2)</option>
      <option>exp(-(x^2 + y^2))</option>
      <option>sin(x^2 + y^2)</option>
      <option>0.5*sin(2*x) + 0.5*cos(2*y)</option>
      <option>(sin(x)+sin(y)) / (1 + 0.1*(x^2 + y^2))</option>
      <option>atan2(y,x)</option>
    </select>
    <button id="plot">Plot</button>
    <button id="reset" class="secondary">Reset View</button>
    <span id="errors"></span>
  </div>
</header>

<main>
  <aside>
    <div class="group">
      <label for="expr">z = f(x, y)</label>
      <textarea id="expr" placeholder="e.g. sin(r)/r  where r = sqrt(x*x + y*y)"></textarea>
    </div>

    <div class="group grid-2">
      <label>x-min <input id="xmin" type="number" step="any" value="-6.28"></label>
      <label>x-max <input id="xmax" type="number" step="any" value="6.28"></label>
    </div>
    <div class="group grid-2">
      <label>y-min <input id="ymin" type="number" step="any" value="-6.28"></label>
      <label>y-max <input id="ymax" type="number" step="any" value="6.28"></label>
    </div>

    <div class="group grid-3">
      <label>Resolution <input id="res" type="number" min="16" max="256" value="96"></label>
      <label>Auto Z <select id="autoz"><option>true</option><option>false</option></select></label>
      <label>FOV° <input id="fov" type="number" min="20" max="100" value="55"></label>
    </div>

    <div class="group grid-2" id="zrange" style="display:none">
      <label>z-min <input id="zmin" type="number" step="any" value="-2"></label>
      <label>z-max <input id="zmax" type="number" step="any" value="2"></label>
    </div>

    <div class="group toggle">
      <label class="chk"><input id="wire" type="checkbox"> Wireframe</label>
      <label class="chk"><input id="axes" type="checkbox" checked> Axes</label>
      <label class="chk"><input id="color" type="checkbox" checked> Height colors</label>
      <label class="chk"><input id="smooth" type="checkbox" checked> Smooth shading</label>
    </div>

    <div class="group">
      <button id="apply">Apply Range</button>
    </div>

    <div class="group">
      <div class="hint">
        <strong>Syntax</strong><br/>
        • Operators: <code>+ - * / % ^</code> (use <code>^</code> for power)<br/>
        • Functions: sin, cos, tan, asin, acos, atan, ln(=log), log10, exp, sqrt, abs, floor, ceil, round, min, max, pow, sign<br/>
        • Built-ins: <code>r = sqrt(x*x + y*y)</code>, <code>theta = atan2(y, x)</code>, constants <code>pi</code>, <code>e</code><br/>
        • Examples: <code>sin(x)*cos(y)</code>, <code>sin(r)/r</code>, <code>exp(-(x^2+y^2))</code>
      </div>
    </div>
  </aside>

  <section id="panel">
    <canvas id="gl"></canvas>
    <footer>
      Tips: Left-drag rotate • Wheel zoom • Right-drag or Shift-drag pan • Double-click to reset.  
      For discontinuities (e.g., <code>1/(x*y)</code>), tighten ranges or lower resolution.
    </footer>
  </section>
</main>

<script>
(() => {
  // ——— DOM
  const glCanvas   = document.getElementById('gl');
  const presetSel  = document.getElementById('preset');
  const plotBtn    = document.getElementById('plot');
  const resetBtn   = document.getElementById('reset');
  const applyBtn   = document.getElementById('apply');
  const errSpan    = document.getElementById('errors');
  const exprTA     = document.getElementById('expr');
  const xminI      = document.getElementById('xmin');
  const xmaxI      = document.getElementById('xmax');
  const yminI      = document.getElementById('ymin');
  const ymaxI      = document.getElementById('ymax');
  const resI       = document.getElementById('res');
  const autozSel   = document.getElementById('autoz');
  const zminI      = document.getElementById('zmin');
  const zmaxI      = document.getElementById('zmax');
  const zrangeDiv  = document.getElementById('zrange');
  const wireChk    = document.getElementById('wire');
  const axesChk    = document.getElementById('axes');
  const colorChk   = document.getElementById('color');
  const smoothChk  = document.getElementById('smooth');

  // ——— GL setup
  const gl = glCanvas.getContext('webgl');
  if (!gl) { errSpan.textContent = "Your browser doesn't support WebGL."; return; }
  gl.getExtension('OES_element_index_uint');

  // HiDPI sizing
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = glCanvas.getBoundingClientRect();
    glCanvas.width  = Math.floor(rect.width * dpr);
    const h = Math.max(280, window.innerHeight - document.querySelector('header').offsetHeight - 120);
    glCanvas.height = Math.floor(h * dpr);
    gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    glCanvas.style.height = Math.floor(glCanvas.height/dpr) + "px";
    draw();
  }
  window.addEventListener('resize', fitCanvas);

  // ——— Shaders
  const VS = `
  attribute vec3 aPos;
  attribute vec3 aNormal;
  uniform mat4 uMVP;
  uniform mat3 uNrmMat;
  uniform float uZMin, uZMax;
  varying vec3 vNormal;
  varying float vZ;
  void main(){
    gl_Position = uMVP * vec4(aPos,1.0);
    vNormal = normalize(uNrmMat * aNormal);
    vZ = aPos.z;
  }`;
  const FS = `
  precision mediump float;
  varying vec3 vNormal;
  varying float vZ;
  uniform vec3 uLightDir;
  uniform float uZMin, uZMax;
  uniform bool uHeightColors;
  uniform bool uSmooth;
  // simple "turbo-ish" colormap
  vec3 turbo(float t){
    t = clamp(t, 0.0, 1.0);
    return vec3(
      0.13572138 + 4.61539260*t - 42.66032258*t*t + 132.13108234*t*t*t - 152.94239396*t*t*t*t + 63.49842801*t*t*t*t*t,
      0.09140261 + 2.94399521*t + 4.91188837*t*t - 14.18503333*t*t*t + 4.80549747*t*t*t*t + 2.47612335*t*t*t*t*t,
      0.10667330 + 9.49438738*t - 31.54016720*t*t + 48.08098422*t*t*t - 23.34165294*t*t*t*t
    );
  }
  void main(){
    vec3 N = normalize(vNormal);
    float diff = max(dot(N, normalize(uLightDir)), 0.0);
    float t = (vZ - uZMin) / max(1e-9, (uZMax - uZMin));
    vec3 base = uHeightColors ? turbo(t) : vec3(0.33, 0.75, 0.95);
    float shade = uSmooth ? (0.25 + 0.75*diff) : 1.0;
    gl_FragColor = vec4(base * shade, 1.0);
  }`;

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src); gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      throw new Error("Shader error: " + gl.getShaderInfoLog(sh));
    }
    return sh;
  }
  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs); gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      throw new Error("Link error: " + gl.getProgramInfoLog(p));
    }
    return p;
  }
  const program = link(compile(gl.VERTEX_SHADER, VS), compile(gl.FRAGMENT_SHADER, FS));
  gl.useProgram(program);
  const aPos = gl.getAttribLocation(program, "aPos");
  const aNormal = gl.getAttribLocation(program, "aNormal");
  const uMVP = gl.getUniformLocation(program, "uMVP");
  const uNrmMat = gl.getUniformLocation(program, "uNrmMat");
  const uLightDir = gl.getUniformLocation(program, "uLightDir");
  const uZMin = gl.getUniformLocation(program, "uZMin");
  const uZMax = gl.getUniformLocation(program, "uZMax");
  const uHeightColors = gl.getUniformLocation(program, "uHeightColors");
  const uSmooth = gl.getUniformLocation(program, "uSmooth");

  // ——— Buffers
  let posBuf = gl.createBuffer();
  let nrmBuf = gl.createBuffer();
  let idxBuf = gl.createBuffer();
  let lineBuf = gl.createBuffer();
  let axesBuf = gl.createBuffer();
  let lineCount = 0, triCount = 0, axesCount = 0;

  // ——— Math utils (tiny mat4/mat3)
  function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
  function mat4Mul(a,b){
    const o=new Array(16);
    for(let r=0;r<4;r++) for(let c=0;c<4;c++){
      o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];
    } return o;
  }
  function mat4Translate(tx,ty,tz){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1]; }
  function mat4Scale(sx,sy,sz){ return [sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1]; }
  function mat4RotX(a){ const c=Math.cos(a),s=Math.sin(a); return [1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]; }
  function mat4RotY(a){ const c=Math.cos(a),s=Math.sin(a); return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]; }
  function perspective(fovy,aspect,near,far){
    const f=1/Math.tan((fovy*Math.PI/180)/2), nf=1/(near-far);
    return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0];
  }
  function mat3FromMat4(m){ return [m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]; }

  // ——— Camera (orbit)
  let yaw=0.7, pitch=0.6, dist=10, panX=0, panY=0;
  let center=[0,0,0];
  let zMin=-1, zMax=1;

  // ——— Expr compiler (safe-ish)
  const allowed = new Set(["sin","cos","tan","asin","acos","atan","log","log10","exp","sqrt","abs","floor","ceil","round","min","max","pow","sign","x","y","r","theta","pi","e","Math"]);
  const forbidden = ["constructor","__proto__","prototype","window","document","self","globalthis","function","eval","import","class","=>","fetch","XML"];
  function sanitize(expr){
    const raw = expr.trim();
    if (!raw) throw new Error("Empty expression.");
    const low = raw.toLowerCase();
    if (forbidden.some(k => low.includes(k))) throw new Error("Expression contains forbidden keyword.");
    let s = raw.replace(/\^/g,"**").replace(/\bln\s*\(/gi,"log(");
    if (/[`"';]/.test(s)) throw new Error("Avoid quotes/semicolons.");
    const ids = s.match(/[A-Za-z_]\w*/g) || [];
    for(const id of ids){
      if (!allowed.has(id)) {
        if (id==="E"||id==="PI") continue;
        if (id!=="x" && id!=="y" && id!=="r" && id!=="theta") throw new Error("Unknown identifier: "+id);
      }
    }
    return s;
  }
  function compile(expr){
    const s = sanitize(expr);
    const src = `
      with (Math) {
        const pi=PI, e=E;
        return function(x,y){
          const r = hypot(x,y);
          const theta = atan2(y,x);
          return (${s});
        }
      }`;
    // eslint-disable-next-line no-new-func
    const fn = new Function(src)();
    // smoke test
    fn(0,0);
    return fn;
  }

  // ——— Mesh builder
  let surfaceFn = (x,y)=>Math.sin(Math.hypot(x,y))/Math.max(1e-9,Math.hypot(x,y));
  let ranges = { xmin:-2*Math.PI, xmax: 2*Math.PI, ymin:-2*Math.PI, ymax:2*Math.PI };
  let res = 96;

  function buildSurface(){
    const nx = Math.max(16, Math.min(256, parseInt(resI.value)||res));
    const ny = nx;
    const xmin = Number(xminI.value), xmax=Number(xmaxI.value);
    const ymin = Number(yminI.value), ymax=Number(ymaxI.value);
    if (!(isFinite(xmin)&&isFinite(xmax)&&xmax>xmin)) throw new Error("Invalid x-range.");
    if (!(isFinite(ymin)&&isFinite(ymax)&&ymax>ymin)) throw new Error("Invalid y-range.");

    ranges = { xmin,xmax,ymin,ymax }; res = nx;

    const xs = new Float32Array((nx+1)*(ny+1)*3);
    const nrm= new Float32Array((nx+1)*(ny+1)*3);
    const dzdx = new Float32Array((nx+1)*(ny+1));
    const dzdy = new Float32Array((nx+1)*(ny+1));
    const dx = (xmax-xmin)/nx, dy=(ymax-ymin)/ny;

    let zmin= Number.POSITIVE_INFINITY, zmax= Number.NEGATIVE_INFINITY;
    function idx(i,j){ return j*(nx+1)+i; }

    // sample heights
    for(let j=0;j<=ny;j++){
      const y = ymin + j*dy;
      for(let i=0;i<=nx;i++){
        const x = xmin + i*dx;
        let z = surfaceFn(x,y);
        if (!isFinite(z)) z = NaN;
        const k = idx(i,j)*3;
        xs[k] = x; xs[k+1]=y; xs[k+2]= z;
        if (isFinite(z)) { if (z<zmin) zmin=z; if (z>zmax) zmax=z; }
      }
    }

    // z range
    if (autozSel.value === "true" || !isFinite(Number(zminI.value)) || !isFinite(Number(zmaxI.value))) {
      zMin = (zmin===Infinity? -1: zmin);
      zMax = (zmax===-Infinity? 1: zmax);
      if (zMax - zMin < 1e-6) { zMin -= 1; zMax += 1; }
      zminI.value = zMin.toFixed(4); zmaxI.value = (zMax).toFixed(4);
    } else {
      zMin = Number(zminI.value); zMax = Number(zmaxI.value);
    }

    center = [ (xmin+xmax)/2, (ymin+ymax)/2, (zMin+zMax)/2 ];

    // central differences for normals
    for(let j=0;j<=ny;j++){
      for(let i=0;i<=nx;i++){
        const k = idx(i,j);
        const zc = xs[k*3+2];
        let zx1 = xs[idx(Math.min(nx,i+1),j)*3+2];
        let zx0 = xs[idx(Math.max(0,i-1),j)*3+2];
        let zy1 = xs[idx(i,Math.min(ny,j+1))*3+2];
        let zy0 = xs[idx(i,Math.max(0,j-1))*3+2];
        if (!isFinite(zx1)) zx1 = zc;
        if (!isFinite(zx0)) zx0 = zc;
        if (!isFinite(zy1)) zy1 = zc;
        if (!isFinite(zy0)) zy0 = zc;
        const gx = (zx1 - zx0)/(2*dx);
        const gy = (zy1 - zy0)/(2*dy);
        dzdx[k] = gx; dzdy[k] = gy;

        // normal ~ (-dz/dx, -dz/dy, 1)
        let nxv = -gx, nyv = -gy, nzv = 1.0;
        const inv = 1.0/Math.hypot(nxv, nyv, nzv);
        nrm[k*3] = nxv*inv; nrm[k*3+1]=nyv*inv; nrm[k*3+2]=nzv*inv;
      }
    }

    // upload vertices (recentering at origin)
    const centered = new Float32Array(xs.length);
    for(let i=0;i<xs.length;i+=3){
      centered[i]   = xs[i]   - center[0];
      centered[i+1] = xs[i+1] - center[1];
      centered[i+2] = xs[i+2] - center[2];
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, centered, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuf);
    gl.bufferData(gl.ARRAY_BUFFER, nrm, gl.STATIC_DRAW);

    // indices (triangle strips by row with degens)
    const strips = [];
    for(let j=0;j<ny;j++){
      if (j>0){ strips.push(j*(nx+1)); } // degenerate
      for(let i=0;i<=nx;i++){
        strips.push(j*(nx+1)+i, (j+1)*(nx+1)+i);
      }
      if (j<ny-1){ strips.push((j+1)*(nx+1)+nx); } // degenerate
    }
    const idxs = new Uint32Array(strips);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxs, gl.STATIC_DRAW);
    triCount = idxs.length;

    // wireframe lines (grid)
    const lines = [];
    for(let j=0;j<=ny;j++){ // constant y
      for(let i=0;i<nx;i++){
        lines.push(idx(i,j), idx(i+1,j));
      }
    }
    for(let i=0;i<=nx;i++){ // constant x
      for(let j=0;j<ny;j++){
        lines.push(idx(i,j), idx(i,j+1));
      }
    }
    const lineIdx = new Uint32Array(lines);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, lineBuf);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineIdx, gl.STATIC_DRAW);
    lineCount = lineIdx.length;

    // axes (X,Y,Z lines centered)
    const spanX = (xmax-xmin), spanY=(ymax-ymin), spanZ=(zMax - zMin);
    const ax = new Float32Array([
      -spanX/2, 0, 0,  spanX/2, 0, 0,
       0,-spanY/2,0,   0, spanY/2,0,
       0,0,-spanZ/2,   0,0, spanZ/2
    ]);
    gl.bindBuffer(gl.ARRAY_BUFFER, axesBuf);
    gl.bufferData(gl.ARRAY_BUFFER, ax, gl.STATIC_DRAW);
    axesCount = 6;
  }

  // ——— Camera controls
  let dragging=false, panMode=false, lastX=0, lastY=0;
  glCanvas.addEventListener('mousedown', (e)=>{
    dragging=true; lastX=e.clientX; lastY=e.clientY;
    panMode = (e.button===2) || e.shiftKey;
  });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('mousemove', (e)=>{
    if (!dragging) return;
    const dx = e.clientX - lastX, dy = e.clientY - lastY;
    lastX=e.clientX; lastY=e.clientY;
    if (panMode){
      const scale = dist/500;
      panX += dx*scale;
      panY -= dy*scale;
    } else {
      yaw   += dx*0.01;
      pitch += dy*0.01;
      const lim = Math.PI/2 - 0.05;
      if (pitch>lim) pitch=lim; if (pitch<-lim) pitch=-lim;
    }
    draw();
  });
  glCanvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const s = (e.deltaY<0) ? 0.9 : 1.1;
    dist = Math.max(0.5, Math.min(1e6, dist*s));
    draw();
  }, {passive:false});
  glCanvas.addEventListener('dblclick', ()=>{
    yaw=0.7; pitch=0.6; dist = 0.9 * Math.max(ranges.xmax-ranges.xmin, ranges.ymax-ranges.ymin, zMax - zMin);
    panX=0; panY=0; draw();
  });
  glCanvas.addEventListener('contextmenu', e => e.preventDefault());

  // ——— Draw
  function draw(){
    if (!glCanvas.width) return;
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.03,0.06,0.12,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const aspect = glCanvas.width / glCanvas.height;
    const proj = perspective(parseFloat(fovI.value), aspect, 0.1, 1000.0);
    const view = mat4Mul(mat4Translate(0,0,-dist), mat4Translate(panX, panY, 0));
    const rot  = mat4Mul(mat4RotY(yaw), mat4RotX(pitch));
    const model= rot; // already centered geometry
    const mv   = mat4Mul(view, model);
    const mvp  = mat4Mul(proj, mv);
    const nrmMat = mat3FromMat4(rot);

    gl.useProgram(program);
    gl.uniformMatrix4fv(uMVP,false,new Float32Array(mvp));
    gl.uniformMatrix3fv(uNrmMat,false,new Float32Array(nrmMat));
    gl.uniform3f(uLightDir, 0.6, 0.7, 0.5);
    gl.uniform1f(uZMin, zMin - center[2]);
    gl.uniform1f(uZMax, zMax - center[2]);
    gl.uniform1i(uHeightColors, colorChk.checked ? 1 : 0);
    gl.uniform1i(uSmooth, smoothChk.checked ? 1 : 0);

    // surface triangles
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuf);
    gl.enableVertexAttribArray(aNormal);
    gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
    gl.drawElements(gl.TRIANGLE_STRIP, triCount, gl.UNSIGNED_INT, 0);

    // wireframe
    if (wireChk.checked){
      gl.lineWidth(1);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, lineBuf);
      gl.drawElements(gl.LINES, lineCount, gl.UNSIGNED_INT, 0);
    }

    // axes
    if (axesChk.checked){
      gl.disableVertexAttribArray(aNormal); // not needed
      gl.bindBuffer(gl.ARRAY_BUFFER, axesBuf);
      gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
      // simple colored axes via multiple draws
      // X (red)
      gl.uniform1i(uHeightColors, 0); gl.uniform1i(uSmooth, 0);
      gl.drawArrays(gl.LINES, 0, 2);
      // Y (green)
      gl.drawArrays(gl.LINES, 2, 2);
      // Z (blue)
      gl.drawArrays(gl.LINES, 4, 2);
    }
  }

  // Bind FOV input (late because draw() references it)
  const fovI = document.getElementById('fov');

  // ——— Controls
  function rebuild(){
    try{
      surfaceFn = compile(exprTA.value.trim() || "sin(r)/r");
      buildSurface();
      // default distance relative to span
      dist = 0.9 * Math.max(ranges.xmax-ranges.xmin, ranges.ymax-ranges.ymin, zMax - zMin);
      errSpan.textContent = "";
      draw();
    } catch(e){
      errSpan.textContent = e.message || String(e);
    }
  }

  plotBtn.addEventListener('click', rebuild);
  applyBtn.addEventListener('click', rebuild);
  resetBtn.addEventListener('click', ()=>{
    yaw=0.7; pitch=0.6; panX=0; panY=0;
    dist = 0.9 * Math.max(ranges.xmax-ranges.xmin, ranges.ymax-ranges.ymin, zMax - zMin);
    draw();
  });

  presetSel.addEventListener('change', ()=>{
    if (!presetSel.value) return;
    exprTA.value = presetSel.value;
    rebuild();
  });

  autozSel.addEventListener('change', ()=>{
    zrangeDiv.style.display = (autozSel.value==="true") ? "none":"grid";
  });

  // Initial state
  exprTA.value = "sin(r)/r";
  autozSel.value = "true";
  zrangeDiv.style.display = "none";
  fitCanvas();
  rebuild();
})();
</script>
</body>
</html>
