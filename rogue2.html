<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rogue (Single‑File, Browser)</title>
  <style>
    :root {
      color-scheme: dark;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #0b0e14;
      color: #e6e6e6;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    header {
      display: flex; align-items: center; gap: 1rem; padding: .75rem 1rem; border-bottom: 1px solid #1c2333;
      background: linear-gradient(180deg, #0f1320, #0a0d15);
      position: sticky; top: 0; z-index: 5;
    }
    header h1 { font-size: 1rem; margin: 0; letter-spacing: .06em; font-weight: 700; color: #9bd;
    }
    header .controls { font-size: .9rem; opacity: .9 }
    header kbd { background:#1c2233; border:1px solid #2b3550; border-bottom-color:#111827; padding:.05rem .35rem; border-radius:.3rem; box-shadow: inset 0 -1px 0 #111827; }
    #wrap {
      display: grid; grid-template-columns: 1fr 360px; gap: 16px; padding: 12px; height: calc(100% - 56px);
    }
    #screenBox { border:1px solid #1c2333; border-radius: 10px; overflow: hidden; background: #0a0d15; display:flex; flex-direction: column; }
    #screen {
      flex:1;
      line-height: 1.05;
      white-space: pre;
      font-size: 18px; /* tweak for your display */
      letter-spacing: .02em;
      padding: 8px;
      outline: none;
    }
    #hud { padding: .5rem .75rem; border-top:1px solid #131a29; background:#0d1220; display:flex; justify-content: space-between; gap:.5rem; align-items: center; }
    #hud span { white-space: nowrap; }
    #side { border:1px solid #1c2333; border-radius:10px; overflow:hidden; background:#0a0d15; display:flex; flex-direction:column; }
    #log { flex:1; padding:.6rem .75rem; overflow:auto; font-size:.95rem; }
    #log p { margin:.25rem 0; color:#b8c3e0; }
    #buttons { display:grid; grid-template-columns: repeat(2, 1fr); gap:8px; padding:8px; border-top:1px solid #131a29; }
    button { background:#162036; color:#dfe8ff; border:1px solid #243250; border-radius:10px; padding:.6rem .8rem; cursor:pointer; font-weight:600; }
    button:hover { filter: brightness(1.1); }
    #help { padding:.6rem .75rem; border-top:1px solid #131a29; color:#c3d0f0; font-size:.9rem; }
    .bar { height: 8px; background:#152038; border:1px solid #253250; border-radius: 999px; overflow:hidden; }
    .bar > i { display:block; height:100%; background: linear-gradient(90deg,#62d,#9df); }
    @media (max-width: 980px){
      #wrap{ grid-template-columns: 1fr; height:auto }
      #screen{ font-size: 16px }
    }
  </style>
</head>
<body>
  <header>
    <h1>Rogue (Browser Edition)</h1>
    <div class="controls">
      Move: <kbd>←</kbd><kbd>→</kbd><kbd>↑</kbd><kbd>↓</kbd> or <kbd>H</kbd><kbd>J</kbd><kbd>K</kbd><kbd>L</kbd> · Diagonals: <kbd>Y</kbd><kbd>U</kbd><kbd>B</kbd><kbd>N</kbd> · Actions: <kbd>G</kbd> pick up, <kbd>.</kbd> wait, <kbd>&gt;</kbd> descend.
    </div>
  </header>
  <div id="wrap">
    <div id="screenBox">
      <pre id="screen" tabindex="0" aria-label="Rogue game area"></pre>
      <div id="hud">
        <span>HP <div class="bar" style="width:120px; display:inline-block; vertical-align:middle; margin:0 .4rem"><i id="hpbar" style="width:100%"></i></div> <b id="hp"></b>/<b id="hpmax"></b></span>
        <span>Depth: <b id="depth"></b></span>
        <span>Atk: <b id="atk"></b> Def: <b id="def"></b></span>
        <span>Inventory: <b id="invcount"></b></span>
      </div>
    </div>
    <aside id="side">
      <div id="log"></div>
      <div id="buttons">
        <button id="btnNew">New Game</button>
        <button id="btnHelp">Help</button>
        <button id="btnWait">Wait (.)</button>
        <button id="btnPickup">Pick up (G)</button>
      </div>
      <div id="help">
        <strong>Goal:</strong> find the <em>Amulet of Yendor</em> and descend the stairs to escape. Permadeath. Fog‑of‑war. Every run is seeded.
        <br/>Tips: Lure enemies into corridors, use potions wisely, and don’t be afraid to wait a turn.
      </div>
    </aside>
  </div>

  <script>
    // --- Utility ---
    const rand = (n) => Math.floor(Math.random()*n);
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const shuffle = (arr)=>{ for(let i=arr.length-1;i>0;--i){ const j=rand(i+1); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr };

    // Direction maps (including diagonals)
    const DIRS = {
      h: {x:-1,y:0}, j:{x:0,y:1}, k:{x:0,y:-1}, l:{x:1,y:0},
      y: {x:-1,y:-1}, u:{x:1,y:-1}, b:{x:-1,y:1}, n:{x:1,y:1}
    };
    const KEY_TO_DIR = {
      ArrowLeft:'h', ArrowDown:'j', ArrowUp:'k', ArrowRight:'l',
      h:'h', j:'j', k:'k', l:'l', y:'y', u:'u', b:'b', n:'n', H:'h', J:'j', K:'k', L:'l', Y:'y', U:'u', B:'b', N:'n'
    };

    // --- Game Config ---
    const W = 80, H = 28;          // map size
    const VIEW_R = 8;              // sight radius
    const ROOM_ATTEMPTS = 120;     // how many room placement tries
    const MIN_ROOM = 4, MAX_ROOM = 10;

    // Tiles
    const T = { WALL:'#', FLOOR:'.', DOOR:'+', STAIRS:'>', AMULET:'A', CLOSED:'▓' };

    // Entities glyphs
    const GLYPH = { PLAYER:'@', RAT:'r', GOB:'g', ORC:'o', TROLL:'T' };

    // Items
    const IT = { POTION:'!', SWORD:')', ARMOR:'[' };

    // Colors (by char)
    const COLOR = new Map([
      [T.WALL, '#556'], [T.FLOOR, '#99a'], [T.DOOR, '#cc6'], [T.STAIRS, '#9d9'], [T.AMULET,'#fd6'], [T.CLOSED,'#223'],
      [GLYPH.PLAYER, '#fff'], [GLYPH.RAT,'#c8a'], [GLYPH.GOB,'#9c9'], [GLYPH.ORC,'#8fd'], [GLYPH.TROLL,'#fc8'],
      [IT.POTION,'#f68'], [IT.SWORD,'#adf'], [IT.ARMOR,'#8df']
    ]);

    // --- RNG with seed ---
    function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t>>>15, t | 1); t ^= t + Math.imul(t ^ t>>>7, t | 61); return ((t ^ t>>>14) >>> 0) / 4294967296; } }
    let SRAND = mulberry32(Date.now()>>>0);
    function srand(seed){ SRAND = mulberry32(seed>>>0); }
    function sRand(n){ return Math.floor(SRAND()*n); }

    // --- Game State ---
    let state;

    function newGame(seed = (Date.now()>>>0)){
      srand(seed);
      state = {
        seed, depth: 1, w: W, h: H,
        map: new Array(H).fill(null).map(()=>new Array(W).fill(T.CLOSED)),
        seen: new Array(H).fill(null).map(()=>new Array(W).fill(false)),
        player: { x:0, y:0, hp: 18, hpMax:18, atk:4, def:1, alive:true, inv:[] },
        monsters: [],
        items: [],
        stairs: {x:0,y:0},
        amulet: null,
        turn: 0,
        message: []
      };
      buildDungeon();
      log(`Welcome to the Dungeons of Doom. Seed ${seed}.`);
      draw();
    }

    // --- Dungeon Generation ---
    function rect(x,y,w,h){ return {x,y,w,h,cx: Math.floor(x+w/2), cy: Math.floor(y+h/2)} }
    function overlap(a,b){ return !(a.x+a.w+1 < b.x || b.x+b.w+1 < a.x || a.y+a.h+1 < b.y || b.y+b.h+1 < a.y) }

    function carveRoom(r){ for(let yy=r.y; yy<r.y+r.h; yy++){ for(let xx=r.x; xx<r.x+r.w; xx++){ if(xx>0&&yy>0&&xx<W-1&&yy<H-1) state.map[yy][xx]=T.FLOOR; } } }
    function hCorr(x1,x2,y){ for(let x=Math.min(x1,x2); x<=Math.max(x1,x2); x++) if(x>0&&y>0&&x<W-1&&y<H-1) state.map[y][x]=T.FLOOR }
    function vCorr(y1,y2,x){ for(let y=Math.min(y1,y2); y<=Math.max(y1,y2); y++) if(x>0&&y>0&&x<W-1&&y<H-1) state.map[y][x]=T.FLOOR }

    function randRoom(){
      const w = sRand(MAX_ROOM-MIN_ROOM+1)+MIN_ROOM;
      const h = sRand(MAX_ROOM-MIN_ROOM+1)+MIN_ROOM;
      const x = sRand(W-w-2)+1;
      const y = sRand(H-h-2)+1;
      return rect(x,y,w,h);
    }

    function buildDungeon(){
      // fill walls
      for(let y=0;y<H;y++) for(let x=0;x<W;x++) state.map[y][x] = T.WALL;

      // place rooms
      const rooms = [];
      for(let i=0;i<ROOM_ATTEMPTS;i++){
        const r = randRoom();
        if(rooms.every(R=>!overlap(R,r))){ rooms.push(r); carveRoom(r); }
      }
      rooms.sort((a,b)=> a.cx-b.cx);

      // connect rooms via corridors
      for(let i=1;i<rooms.length;i++){
        const a = rooms[i-1], b = rooms[i];
        if(sRand(2)) { hCorr(a.cx,b.cx,a.cy); vCorr(a.cy,b.cy,b.cx); }
        else { vCorr(a.cy,b.cy,a.cx); hCorr(a.cx,b.cx,b.cy); }
      }

      // add some doors at room edges
      for(const r of rooms){
        const doors = [ {x:r.cx,y:r.y-1}, {x:r.cx,y:r.y+r.h}, {x:r.x-1,y:r.cy}, {x:r.x+r.w,y:r.cy} ];
        for(const d of doors){ if(inBounds(d.x,d.y) && isFloorNeighbor(d.x,d.y)) state.map[d.y][d.x] = T.DOOR; }
      }

      // place player in first room
      const start = rooms[0] ?? rect(2,2,8,6);
      state.player.x = start.cx; state.player.y = start.cy;

      // place stairs in a far room
      const end = rooms[rooms.length-1] ?? rect(W-12,H-10,8,6);
      state.stairs.x = end.cx; state.stairs.y = end.cy; state.map[end.cy][end.cx] = T.STAIRS;

      // place amulet from depth 5+
      if(state.depth >= 5){
        let placed = false; let tries = 0;
        while(!placed && tries++ < 500){
          const r = rooms[sRand(rooms.length)]; if(!r) break;
          const x = sRand(r.w)+r.x, y = sRand(r.h)+r.y;
          if((x!==state.stairs.x||y!==state.stairs.y) && isWalkable(x,y)){
            state.amulet = {x,y};
            state.map[y][x] = T.AMULET; placed = true;
          }
        }
      }

      // populate monsters & items
      const density = 0.015 + state.depth*0.002;
      for(let y=1;y<H-1;y++) for(let x=1;x<W-1;x++){
        if(state.map[y][x]===T.FLOOR && Math.random()<density){
          // 60% monster, 40% item
          if(Math.random()<0.6) spawnMonster(x,y); else dropItem(x,y);
        }
      }
      // ensure at least a couple potions
      for(let i=0;i<3;i++) dropItem(start.x + sRand(3)-1, start.y + sRand(3)-1);
    }

    function inBounds(x,y){ return x>=0 && y>=0 && x<W && y<H }
    function isWalkable(x,y){ const t = state.map[y][x]; return t===T.FLOOR || t===T.DOOR || t===T.STAIRS || t===T.AMULET }
    function isFloorNeighbor(x,y){
      for(const d of Object.values(DIRS)){
        const nx=x+d.x, ny=y+d.y; if(inBounds(nx,ny) && state.map[ny][nx]===T.FLOOR) return true;
      } return false;
    }

    // --- Entities ---
    function spawnMonster(x,y){
      const roll = sRand(100);
      let type, hp, atk, def;
      if(roll<45){ type=GLYPH.RAT; hp=4; atk=2; def=0; }
      else if(roll<75){ type=GLYPH.GOB; hp=7; atk=3; def=1; }
      else if(roll<93){ type=GLYPH.ORC; hp=10; atk=4; def=2; }
      else { type=GLYPH.TROLL; hp=16; atk=5; def=3; }
      state.monsters.push({x,y,type,hp,atk,def,seen:false});
    }

    function dropItem(x,y){
      const r = sRand(100);
      let type = IT.POTION;
      if(r<55) type = IT.POTION; else if(r<80) type = IT.SWORD; else type = IT.ARMOR;
      state.items.push({x,y,type});
    }

    function itemAt(x,y){ return state.items.find(i=>i.x===x && i.y===y) }
    function monsterAt(x,y){ return state.monsters.find(m=>m.x===x && m.y===y) }

    // --- FOV (Bresenham LOS) ---
    function blocks(x,y){ const t = state.map[y][x]; return t===T.WALL }
    function los(x0,y0,x1,y1){
      let dx=Math.abs(x1-x0), dy=Math.abs(y1-y0), sx=x0<x1?1:-1, sy=y0<y1?1:-1, err=dx-dy, x=x0,y=y0;
      while(true){ if(blocks(x,y) && !(x===x0&&y===y0)) return false; if(x===x1 && y===y1) return true; const e2=2*err; if(e2>-dy){ err-=dy; x+=sx; } if(e2<dx){ err+=dx; y+=sy; } }
    }

    function computeVisibility(){
      const {x:px,y:py} = state.player;
      for(let y=0;y<H;y++) for(let x=0;x<W;x++){
        const d = Math.hypot(x-px,y-py);
        const vis = d <= VIEW_R && los(px,py,x,y);
        state.seen[y][x] = state.seen[y][x] || vis;
      }
    }

    // --- Rendering ---
    function draw(){
      computeVisibility();
      const scr = [];
      const {x:px,y:py} = state.player;
      for(let y=0;y<H;y++){
        let line = '';
        for(let x=0;x<W;x++){
          const visible = Math.hypot(x-px,y-py)<=VIEW_R && los(px,py,x,y);
          let ch = ' ';
          if(visible){
            let base = state.map[y][x];
            const m = monsterAt(x,y); if(m) base = m.type;
            const it = itemAt(x,y); if(it) base = it.type;
            if(px===x && py===y) base = GLYPH.PLAYER;
            ch = base;
          } else if(state.seen[y][x]){
            const t = state.map[y][x];
            ch = (t===T.WALL?'#':t===T.DOOR?'+':t===T.FLOOR?'.':' ');
          } else {
            ch = ' ';
          }
          line += ch;
        }
        scr.push(line);
      }
      // colorize using spans (basic):
      const colored = scr.map((line,y)=>{
        let out='';
        for(let x=0;x<line.length;x++){
          const ch = line[x];
          const col = COLOR.get(ch);
          if(col) out += `<span style="color:${col}">${ch}</span>`; else out += ch;
        }
        return out;
      }).join("\n");
      screen.innerHTML = colored;

      // HUD
      hp.textContent = state.player.hp;
      hpmax.textContent = state.player.hpMax;
      hpbar.style.width = Math.max(0, 100*state.player.hp/state.player.hpMax) + '%';
      depth.textContent = state.depth;
      atk.textContent = state.player.atk;
      def.textContent = state.player.def;
      invcount.textContent = state.player.inv.length;
    }

    // --- Logging ---
    function log(msg){
      state.message.push(msg);
      const p = document.createElement('p'); p.textContent = msg; logEl.appendChild(p); logEl.scrollTop = logEl.scrollHeight;

        // Speak the message in American English (toggleable)
      try {
        if ('speechSynthesis' in window) {
          const utter = new SpeechSynthesisUtterance(msg);
          utter.lang = 'en-US';   // American English
          utter.rate = 1.0;       // normal speed
          utter.pitch = 1.0;      // natural pitch
          speechSynthesis.cancel();  // avoid long queues
          speechSynthesis.speak(utter);
        }
      } catch (_) { /* ignore speech errors */ }
    }

    // --- Combat & Items ---
    function damageRoll(atk, def){
      const base = Math.max(0, atk - Math.floor(def/2));
      return 1 + sRand(base + 2);
    }

    function attack(attacker, defender){
      const hit = sRand(100) < 75; // 75% to hit
      if(!hit){ log(`Miss!`); return; }
      const dmg = Math.max(1, damageRoll(attacker.atk, defender.def));
      defender.hp -= dmg; log(`${glyph(attacker)} hits ${glyph(defender)} for ${dmg}.`);
      if(defender.hp<=0){
        if(defender===state.player){
          log(`You die... Press "New Game" to try again. Seed ${state.seed}.`);
          state.player.alive=false;
        } else {
          log(`The ${nameOf(defender)} dies.`);
          // chance to drop a potion
          if(Math.random()<0.15) state.items.push({x:defender.x,y:defender.y,type:IT.POTION});
          // remove monster
          state.monsters = state.monsters.filter(m=>m!==defender);
        }
      }
    }

    function glyph(ent){ return ent===state.player? 'You' : nameOf(ent) }
    function nameOf(ent){
      switch(ent.type){
        case GLYPH.RAT: return 'rat';
        case GLYPH.GOB: return 'goblin';
        case GLYPH.ORC: return 'orc';
        case GLYPH.TROLL: return 'troll';
        default: return 'thing';
      }
    }

    function pickUp(){
      const it = itemAt(state.player.x, state.player.y);
      if(!it){ log('Nothing here.'); return; }
      state.items = state.items.filter(o=>o!==it);
      if(it.type===IT.POTION){ state.player.inv.push({type:IT.POTION}); log('Picked up a potion (!). Use automatically when low.'); }
      if(it.type===IT.SWORD){ state.player.atk += 1 + sRand(2); log('You equip a sharper sword.) Atk up!'); }
      if(it.type===IT.ARMOR){ state.player.def += 1 + sRand(2); log('You don tougher armor.[ Def up!'); }
      if(it.type===T.AMULET){ log('You pick up the Amulet of Yendor! Find the stairs and escape!'); }
      draw();
    }

    // auto-use potion at low HP
    function maybeAutoUsePotion(){
      if(state.player.hp <= Math.ceil(state.player.hpMax/3)){
        const idx = state.player.inv.findIndex(i=>i.type===IT.POTION);
        if(idx>=0){
          state.player.inv.splice(idx,1);
          const heal = 6 + sRand(6);
          state.player.hp = Math.min(state.player.hpMax, state.player.hp + heal);
          log(`You quaff a healing potion and recover ${heal} HP.`);
        }
      }
    }

    // --- Movement & Turns ---
    function tryMove(dx,dy){
      if(!state.player.alive) return;
      const nx = clamp(state.player.x+dx, 0, W-1);
      const ny = clamp(state.player.y+dy, 0, H-1);
      if(!isWalkable(nx,ny) && state.map[ny][nx]!==T.AMULET) return;
      const m = monsterAt(nx,ny);
      if(m){ attack(state.player, m); }
      else { state.player.x = nx; state.player.y = ny; }
      endTurn();
    }

    function wait(){ if(!state.player.alive) return; endTurn(); }

    function descend(){
      const {x,y} = state.player; if(x===state.stairs.x && y===state.stairs.y){
        if(state.depth>=5 && state.amulet && state.map[y][x]!==T.STAIRS){ /* shouldn't happen */ }
        nextDepth();
      } else log('No stairs here.');
    }

    function nextDepth(){
      state.depth++;
      // slight stat scaling per depth
      state.player.hpMax += 1; state.player.hp = state.player.hpMax; state.player.atk += (state.depth%2===0?1:0);
      state.monsters = []; state.items = []; state.seen = new Array(H).fill(null).map(()=>new Array(W).fill(false));
      state.amulet = state.amulet ? state.amulet : null; // carry flag only
      buildDungeon();
      log(`You descend to depth ${state.depth}.`);
      draw();
    }

    function endTurn(){
      state.turn++;
      // monsters act
      for(const m of [...state.monsters]){
        if(!state.player.alive) break;
        // if adjacent, attack
        const dx = state.player.x - m.x, dy = state.player.y - m.y;
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        if(dist<=1){ attack(m, state.player); continue; }
        // if in LOS and within chase distance, move closer
        const canSee = Math.hypot(dx,dy) <= VIEW_R+2 && los(m.x, m.y, state.player.x, state.player.y);
        let mdx=0, mdy=0;
        if(canSee){ mdx = Math.sign(dx); mdy = Math.sign(dy); }
        else {
          // wander
          const d = shuffle(Object.values(DIRS))[0]; mdx=d.x; mdy=d.y;
        }
        const nx = m.x + mdx, ny = m.y + mdy;
        if(inBounds(nx,ny) && isWalkable(nx,ny) && !monsterAt(nx,ny) && !(state.player.x===nx && state.player.y===ny)){
          m.x = nx; m.y = ny;
        }
      }

      if(state.player.alive){ maybeAutoUsePotion(); draw(); }
    }

    // --- Input ---
    const screen = document.getElementById('screen');
    const logEl = document.getElementById('log');
    const hp = document.getElementById('hp');
    const hpmax = document.getElementById('hpmax');
    const hpbar = document.getElementById('hpbar');
    const depth = document.getElementById('depth');
    const atk = document.getElementById('atk');
    const def = document.getElementById('def');
    const invcount = document.getElementById('invcount');

    document.addEventListener('keydown', (e)=>{
      const dirKey = KEY_TO_DIR[e.key];
      if(dirKey){ e.preventDefault(); const d = DIRS[dirKey]; tryMove(d.x, d.y); return; }
      if(e.key==='.' ){ e.preventDefault(); wait(); return; }
      if(e.key==='g' || e.key==='G'){ e.preventDefault(); pickUp(); return; }
      if(e.key==='>' ){ e.preventDefault(); descend(); return; }
    });

    // Buttons
    btnNew.onclick = ()=>{ logEl.innerHTML=''; newGame(); };
    btnHelp.onclick = ()=>{
      alert(`Controls\n\nArrows or HJKL to move, YUBN for diagonals.\nG = pick up, "." = wait, ">" = descend.\nGoal: find the Amulet (A) at depth >= 5, then reach stairs (>) to escape.\n\nPro tips: Fight in hallways, rest when safe, and auto-heal uses a potion at low HP if you have one.`);
      screen.focus();
    };
    btnWait.onclick = ()=>{ wait(); };
    btnPickup.onclick = ()=>{ pickUp(); };

    // Start
    newGame();
    screen.focus();
  </script>
</body>
</html>
