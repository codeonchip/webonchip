<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple Block Diagram Editor</title>
<style>
  :root{ --bg:#0b0f19; --panel:#121938; --panel2:#0e1430; --line:#2944a2; --accent:#7cb8ff; --text:#eaf4ff; --muted:#a8c7ff; --ok:#62d391; --warn:#ffd98a; --danger:#ff6b6b; }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 50% -10%, #14215a, var(--bg));color:var(--text);font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
  .wrap{display:grid;grid-template-columns:280px 1fr;gap:12px;padding:12px}
  .panel{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid #24317a;border-radius:14px;box-shadow:0 10px 24px #0008}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;padding:10px}
  .btn{background:#0b1338;border:1px solid var(--accent);padding:8px 10px;border-radius:10px;color:var(--text);font-weight:700;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .btn.danger{border-color:var(--danger);color:#ffd7d7}
  .btn.ok{border-color:var(--ok)}
  .sidebar{padding:10px}
  .sidebar h2{margin:8px 6px 6px 6px;font-size:15px;color:var(--muted)}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:6px;align-items:center}
  input[type="text"],input[type="number"],select{width:100%;background:#0b1338;border:1px solid #3854b6;color:var(--text);border-radius:8px;padding:6px 8px}
  .small{font-size:12px;color:var(--muted)}
  .canvas-panel{position:relative}
  svg{display:block;width:100%;height:75vh;background:#000;border-radius:14px;border:2px solid #2944a2;box-shadow:inset 0 0 40px #000, 0 20px 40px #000a}
  .grid line{stroke:#1a2a66;stroke-width:1}
  .node rect{fill:#0b1338;stroke:#6ea2ff;stroke-width:2;rx:10;ry:10}
  .node text{fill:#eaf4ff;font:600 12px ui-monospace,Consolas}
  .port{fill:#ffd98a;stroke:#ffbf3e;stroke-width:1}
  .link{stroke:#7cb8ff;stroke-width:2;fill:none;marker-end:url(#arrow)}
  .link.selected{stroke:#ffd800}
  .node.selected rect{stroke:#ffd800}
  .selbox{fill:rgba(124,184,255,0.15);stroke:#7cb8ff;stroke-dasharray:6 6}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel sidebar">
    <div class="toolbar">
      <button class="btn" id="addBlock">+ Block</button>
      <button class="btn" id="addArrow">âžœ Link</button>
      <button class="btn" id="modeSelect">â†– Select</button>
      <button class="btn" id="modePan">âœ¥ Pan</button>
      <button class="btn" id="delete" title="Del">ðŸ—‘ Delete</button>
      <button class="btn ok" id="exportJSON">Export</button>
      <button class="btn ok" id="importJSON">Import</button>
      <button class="btn" id="exportSVG">SVG</button>
      <button class="btn" id="exportPNG">PNG</button>
    </div>
    <h2>Selected</h2>
    <div id="inspector" class="small">Nothing selected</div>
    <h2>Tips</h2>
    <div class="small">Gridâ€‘snap (16px). <b>Drag</b> blocks to move. <b>Ports</b> on each side. <b>Link mode</b>: click a source port then a target port. <b>Pan</b> by dragging background. <b>Wheel</b> to zoom. <b>Del</b> to delete. <b>Ctrl/Cmd+S</b> to save JSON.</div>
  </div>

  <div class="panel canvas-panel">
    <div class="toolbar">
      <span class="small">Mode: <span id="modeLabel">Select</span> â€¢ Zoom: <span id="zoomLabel">100%</span> â€¢ Nodes: <span id="statsNodes">0</span> â€¢ Links: <span id="statsLinks">0</span></span>
    </div>
    <svg id="stage" viewBox="0 0 2000 1200" tabindex="0" aria-label="Block diagram editor">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="#7cb8ff"></path>
        </marker>
      </defs>
      <g id="grid" class="grid"></g>
      <g id="links"></g>
      <g id="nodes"></g>
      <rect id="selbox" class="selbox" x="0" y="0" width="0" height="0" visibility="hidden"/>
    </svg>
  </div>
</div>

<script>
// ---------- State ----------
const svg = document.getElementById('stage');
const gGrid = document.getElementById('grid');
const gNodes = document.getElementById('nodes');
const gLinks = document.getElementById('links');
const selbox = document.getElementById('selbox');
const modeLabel = document.getElementById('modeLabel');
const zoomLabel = document.getElementById('zoomLabel');
const statsNodes = document.getElementById('statsNodes');
const statsLinks = document.getElementById('statsLinks');
const inspector = document.getElementById('inspector');

const GRID=16;
let mode = 'select'; // 'select' | 'addBlock' | 'addLink' | 'pan'
let zoom = 1, view = {x:0,y:0};
let nodes=[], links=[]; // node: {id,x,y,w,h,label}; link: {id,from:{id,side},to:{id,side}}
let selection = {nodeId:null, linkId:null};
let linking = {from:null};
let drag = null; // {type:'node'|'pan', id, ox, oy}

// ---------- Helpers ----------
const uid = () => 'id'+Math.random().toString(36).slice(2,9);
const snap = (v)=> Math.round(v/GRID)*GRID;
function setMode(m){ mode=m; modeLabel.textContent = m==='addBlock'?'Add Block': m==='addLink'?'Link' : m==='pan'?'Pan' : 'Select'; }
function updateStats(){ statsNodes.textContent = nodes.length; statsLinks.textContent = links.length; }

// grid
function drawGrid(){
  const W=2000, H=1200; gGrid.innerHTML='';
  for(let x=0;x<=W;x+=GRID){ const l=line(x,0,x,H); gGrid.appendChild(l); }
  for(let y=0;y<=H;y+=GRID){ const l=line(0,y,2000,y); gGrid.appendChild(l); }
}
function line(x1,y1,x2,y2){ const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2); return l; }

// ---------- Nodes & links rendering ----------
function render(){
  gNodes.innerHTML='';
  for(const n of nodes){ gNodes.appendChild(renderNode(n)); }
  gLinks.innerHTML='';
  for(const e of links){ gLinks.appendChild(renderLink(e)); }
  updateStats();
  renderInspector();
}

function renderNode(n){
  const g = svgEl('g',{class:'node'+(selection.nodeId===n.id?' selected':''),transform:`translate(${n.x} ${n.y})`, 'data-id':n.id});
  const rect = svgEl('rect',{x:0,y:0,width:n.w,height:n.h});
  const text = svgEl('text',{x:n.w/2,y:n.h/2,'text-anchor':'middle','dominant-baseline':'middle'});
  text.textContent = n.label || 'Block';
  g.append(rect,text);
  // ports
  const ports=[['left',0,n.h/2],['right',n.w,n.h/2],['top',n.w/2,0],['bottom',n.w/2,n.h]];
  for(const [side,px,py] of ports){
    const p = svgEl('circle',{class:'port','data-side':side,cx:px,cy:py,r:5}); g.appendChild(p);
  }
  // drag
  g.addEventListener('pointerdown',(e)=>{
    if(e.target.classList.contains('port')) return; // handled in link mode
    if(mode==='select'){
      selection = {nodeId:n.id, linkId:null}; render();
      drag = {type:'node', id:n.id, ox:e.clientX, oy:e.clientY, sx:n.x, sy:n.y}; svg.setPointerCapture(e.pointerId);
    }
  });
  g.addEventListener('dblclick',()=>{ // quick edit label
    const val = prompt('Block label', n.label||'Block'); if(val!=null){ n.label = val; render(); }
  });
  // link start/end
  g.querySelectorAll('.port').forEach(port=>{
    port.addEventListener('pointerdown',(e)=>{
      const side = port.getAttribute('data-side');
      if(mode!=='addLink') return;
      if(!linking.from){ linking.from = {id:n.id, side}; selection={nodeId:null, linkId:null}; }
      else {
        if(linking.from.id!==n.id || linking.from.side!==side){
          links.push({id:uid(), from:linking.from, to:{id:n.id, side}}); linking.from=null; render();
        }
      }
      e.stopPropagation();
    });
  });
  return g;
}

function renderLink(e){
  const a = portPos(e.from), b = portPos(e.to);
  const path = orthPath(a,b);
  const p = svgEl('path',{class:'link'+(selection.linkId===e.id?' selected':''), d:path});
  p.addEventListener('pointerdown',(ev)=>{ if(mode==='select'){ selection={nodeId:null, linkId:e.id}; render(); ev.stopPropagation(); } });
  return p;
}

function portPos(ref){
  const n = nodes.find(x=>x.id===ref.id); if(!n) return {x:0,y:0};
  const offset = {left:[0,n.h/2], right:[n.w,n.h/2], top:[n.w/2,0], bottom:[n.w/2,n.h]}[ref.side];
  return {x:n.x+offset[0], y:n.y+offset[1]};
}

function orthPath(a,b){
  const mX = (a.x + b.x)/2; // simple 2â€‘segment ortho
  return `M ${a.x} ${a.y} L ${mX} ${a.y} L ${mX} ${b.y} L ${b.x} ${b.y}`;
}

function svgEl(tag,attrs){ const e=document.createElementNS('http://www.w3.org/2000/svg',tag); for(const[k,v]of Object.entries(attrs||{})) e.setAttribute(k,v); return e; }

// ---------- Interaction ----------
svg.addEventListener('pointermove',(e)=>{
  if(drag&&drag.type==='node'){
    const dx=e.clientX-drag.ox, dy=e.clientY-drag.oy; const n=nodes.find(x=>x.id===drag.id);
    n.x = snap(drag.sx + dx/zoom + view.x); n.y = snap(drag.sy + dy/zoom + view.y); render();
  }
  if(drag&&drag.type==='pan'){
    view.x = drag.sx - (e.clientX-drag.ox)/100; view.y = drag.sy - (e.clientY-drag.oy)/100; updateViewBox();
  }
});
svg.addEventListener('pointerup',(e)=>{ if(drag){ svg.releasePointerCapture(e.pointerId); drag=null; }});
svg.addEventListener('pointerdown',(e)=>{
  if(e.target===svg || e.target.parentNode===gGrid){
    if(mode==='pan'){
      drag={type:'pan',ox:e.clientX,oy:e.clientY,sx:view.x,sy:view.y}; svg.setPointerCapture(e.pointerId); return;
    }
    // selection box start
    if(mode==='select'){
      const pt = clientToSvg(e.clientX,e.clientY); selbox.setAttribute('x',pt.x); selbox.setAttribute('y',pt.y); selbox.setAttribute('width',0); selbox.setAttribute('height',0); selbox.setAttribute('visibility','visible');
      drag={type:'sel',ox:pt.x,oy:pt.y}; svg.setPointerCapture(e.pointerId);
    }
    selection={nodeId:null, linkId:null}; render();
  }
});
svg.addEventListener('pointermove',(e)=>{
  if(drag&&drag.type==='sel'){
    const pt = clientToSvg(e.clientX,e.clientY); const x=Math.min(drag.ox,pt.x), y=Math.min(drag.oy,pt.y), w=Math.abs(pt.x-drag.ox), h=Math.abs(pt.y-drag.oy);
    selbox.setAttribute('x',x); selbox.setAttribute('y',y); selbox.setAttribute('width',w); selbox.setAttribute('height',h);
  }
});
svg.addEventListener('pointerup',(e)=>{
  if(drag&&drag.type==='sel'){
    selbox.setAttribute('visibility','hidden');
    // select first node inside
    const x=+selbox.getAttribute('x'), y=+selbox.getAttribute('y'), w=+selbox.getAttribute('width'), h=+selbox.getAttribute('height');
    const found = nodes.find(n=> n.x>=x && n.y>=y && (n.x+n.w)<=x+w && (n.y+n.h)<=y+h );
    if(found) selection={nodeId:found.id, linkId:null}; render();
  }
});

// wheel zoom
svg.addEventListener('wheel',(e)=>{ e.preventDefault(); const delta = Math.sign(e.deltaY)*-0.1; zoom = Math.min(2, Math.max(0.5, zoom+delta)); updateViewBox(); });
function updateViewBox(){ svg.setAttribute('viewBox', `${view.x*100} ${view.y*100} ${2000/zoom} ${1200/zoom}`); zoomLabel.textContent = Math.round(zoom*100)+'%'; }

// keyboard
window.addEventListener('keydown',(e)=>{
  if(e.key==='Delete'){ delSelected(); }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='s'){ e.preventDefault(); download('diagram.json', JSON.stringify({nodes,links},null,2)); }
});

// sidebar buttons
q('#addBlock').onclick=()=>{ setMode('addBlock'); };
q('#addArrow').onclick=()=>{ setMode('addLink'); };
q('#modeSelect').onclick=()=>{ setMode('select'); };
q('#modePan').onclick=()=>{ setMode('pan'); };
q('#delete').onclick=delSelected;
q('#exportJSON').onclick=()=>download('diagram.json', JSON.stringify({nodes,links},null,2));
q('#importJSON').onclick=importJSON;
q('#exportSVG').onclick=()=>download('diagram.svg', exportSVG());
q('#exportPNG').onclick=exportPNG;

// click to add block
svg.addEventListener('dblclick',(e)=>{
  if(mode!=='addBlock') return; const pt=clientToSvg(e.clientX,e.clientY);
  nodes.push({id:uid(), x:snap(pt.x-60), y:snap(pt.y-30), w:120, h:60, label:'Block'}); setMode('select'); render();
});

// background click cancels linking
svg.addEventListener('click',(e)=>{ if(e.target===svg && mode==='addLink'){ linking.from=null; }});

function delSelected(){
  if(selection.nodeId){
    const id=selection.nodeId; links=links.filter(l=>l.from.id!==id && l.to.id!==id); nodes=nodes.filter(n=>n.id!==id); selection={nodeId:null,linkId:null}; render();
  } else if(selection.linkId){ links=links.filter(l=>l.id!==selection.linkId); selection={nodeId:null,linkId:null}; render(); }
}

// inspector
function renderInspector(){
  if(selection.nodeId){
    const n = nodes.find(x=>x.id===selection.nodeId); if(!n){ inspector.textContent=''; return; }
    inspector.innerHTML = `<div class="kv small">
      <div>ID</div><div class="mono">${n.id}</div>
      <div>Label</div><div><input id="lbl" type="text" value="${n.label}"></div>
      <div>X</div><div><input id="nx" type="number" value="${n.x}"></div>
      <div>Y</div><div><input id="ny" type="number" value="${n.y}"></div>
      <div>W</div><div><input id="nw" type="number" value="${n.w}"></div>
      <div>H</div><div><input id="nh" type="number" value="${n.h}"></div>
    </div>`;
    q('#lbl').oninput=(e)=>{ n.label=e.target.value; render(); };
    q('#nx').oninput=(e)=>{ n.x=snap(+e.target.value||0); render(); };
    q('#ny').oninput=(e)=>{ n.y=snap(+e.target.value||0); render(); };
    q('#nw').oninput=(e)=>{ n.w=Math.max(32, +e.target.value||120); render(); };
    q('#nh').oninput=(e)=>{ n.h=Math.max(24, +e.target.value||60); render(); };
  } else if(selection.linkId){
    const l = links.find(x=>x.id===selection.linkId);
    inspector.innerHTML = `<div class="kv small">
      <div>ID</div><div class="mono">${l.id}</div>
      <div>From</div><div class="mono">${l.from.id}.${l.from.side}</div>
      <div>To</div><div class="mono">${l.to.id}.${l.to.side}</div>
    </div>`;
  } else {
    inspector.textContent='Nothing selected';
  }
}

// JSON import/export
function importJSON(){ const inp=document.createElement('input'); inp.type='file'; inp.accept='.json,application/json'; inp.onchange=()=>{ const f=inp.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ try{ const o=JSON.parse(r.result); nodes=o.nodes||[]; links=o.links||[]; render(); }catch(err){ alert('Invalid JSON'); } }; r.readAsText(f); }; inp.click(); }
function exportSVG(){
  // build an SVG doc string with nodes+links only (no grid/selbox)
  const doc = document.implementation.createDocument('http://www.w3.org/2000/svg','svg',null);
  const root = doc.documentElement; root.setAttribute('xmlns','http://www.w3.org/2000/svg'); root.setAttribute('viewBox','0 0 2000 1200'); root.setAttribute('width','1200'); root.setAttribute('height','720');
  const defs = doc.createElementNS('http://www.w3.org/2000/svg','defs'); const marker=doc.createElementNS('http://www.w3.org/2000/svg','marker'); marker.setAttribute('id','arrow'); marker.setAttribute('viewBox','0 0 10 10'); marker.setAttribute('refX','10'); marker.setAttribute('refY','5'); marker.setAttribute('markerWidth','7'); marker.setAttribute('markerHeight','7'); marker.setAttribute('orient','auto-start-reverse'); const mpath=doc.createElementNS('http://www.w3.org/2000/svg','path'); mpath.setAttribute('d','M0 0 L10 5 L0 10 Z'); mpath.setAttribute('fill','#000'); marker.appendChild(mpath); defs.appendChild(marker); root.appendChild(defs);
  const G=doc.createElementNS('http://www.w3.org/2000/svg','g'); root.appendChild(G);
  for(const e of links){ const a=portPos(e.from), b=portPos(e.to); const p=doc.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d', orthPath(a,b)); p.setAttribute('stroke','#000'); p.setAttribute('stroke-width','2'); p.setAttribute('fill','none'); p.setAttribute('marker-end','url(#arrow)'); G.appendChild(p); }
  for(const n of nodes){ const g=doc.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('transform',`translate(${n.x} ${n.y})`); const r=doc.createElementNS('http://www.w3.org/2000/svg','rect'); r.setAttribute('x','0'); r.setAttribute('y','0'); r.setAttribute('width',n.w); r.setAttribute('height',n.h); r.setAttribute('rx','10'); r.setAttribute('ry','10'); r.setAttribute('fill','#fff'); r.setAttribute('stroke','#000'); r.setAttribute('stroke-width','2'); g.appendChild(r); const t=doc.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x',n.w/2); t.setAttribute('y',n.h/2); t.setAttribute('text-anchor','middle'); t.setAttribute('dominant-baseline','middle'); t.textContent=n.label||'Block'; g.appendChild(t); root.appendChild(g); }
  const serializer=new XMLSerializer(); return serializer.serializeToString(root);
}
async function exportPNG(){
  const svgStr = exportSVG(); const img = new Image(); const blob = new Blob([svgStr],{type:'image/svg+xml'}); const url=URL.createObjectURL(blob);
  await new Promise(res=>{ img.onload=()=>res(); img.src=url; });
  const cnv=document.createElement('canvas'); cnv.width=1200; cnv.height=720; const cx=cnv.getContext('2d'); cx.fillStyle='#fff'; cx.fillRect(0,0,cnv.width,cnv.height); cx.drawImage(img,0,0); URL.revokeObjectURL(url);
  cnv.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='diagram.png'; a.click(); },'image/png');
}

// utils
function q(s){ return document.querySelector(s); }
function download(name, text){ const blob=new Blob([text],{type:'application/octet-stream'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); }
function clientToSvg(cx,cy){ const pt = svg.createSVGPoint(); pt.x=cx; pt.y=cy; const m = svg.getScreenCTM().inverse(); const r = pt.matrixTransform(m); return {x:r.x, y:r.y}; }

// init
drawGrid();
// starter nodes
nodes=[
  {id:uid(), x:160, y:140, w:160, h:70, label:'Input'},
  {id:uid(), x:480, y:140, w:180, h:70, label:'Process'},
  {id:uid(), x:820, y:140, w:160, h:70, label:'Output'}
];
links=[{id:uid(), from:{id:nodes[0].id, side:'right'}, to:{id:nodes[1].id, side:'left'}}, {id:uid(), from:{id:nodes[1].id, side:'right'}, to:{id:nodes[2].id, side:'left'}}];
render();
updateViewBox();
</script>
</body>
</html>
