<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Web Shell</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-900">
  <div id="root"></div>

  <!-- React + ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel to handle JSX in the browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    // --- helpers
    const nowString = () => new Date().toLocaleString();
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const toHex = (n, width=8) => "0x" + (n>>>0).toString(16).toUpperCase().padStart(width, "0");
    const isHex = (s) => /^0x[0-9a-f]+$/i.test(s);
    const parseNum = (s) => isHex(s) ? parseInt(s, 16) : Number(s);

    function splitArgs(line) {
      const out = []; let cur = ""; let quote = null;
      for (let i=0;i<line.length;i++) {
        const ch = line[i];
        if (quote) {
          if (ch === quote) { quote = null; } else { cur += ch; }
        } else {
          if (ch === '"' || ch === "'") quote = ch;
          else if (ch === " ") { if (cur.length) { out.push(cur); cur = ""; } }
          else cur += ch;
        }
      }
      if (cur.length) out.push(cur);
      return out;
    }

    function parseFlags(argv) {
      const flags = {}, args = [];
      for (const token of argv) {
        if (token.startsWith("--")) {
          const [k,v] = token.slice(2).split("=");
          flags[k] = v === undefined ? true : v;
        } else args.push(token);
      }
      return {flags, args};
    }

    // --- virtual FS
    function makeDefaultVFS() {
      return {
        type: "dir", name: "/", children: {
          home: { type: "dir", name: "home", children: {
            guest: { type: "dir", name: "guest", children: {
              "readme.txt": { type: "file", name: "readme.txt", data:
`Welcome to Web Shell!

Try:
  help              # list commands
  ls, cd, cat       # explore this virtual FS
  calc 1+2*3        # quick calculator
  crc32 --help      # CRC-32 (customizable)
  base64 encode hello
  curl https://example.com
  uname, whoami, date, pwd

Tip: Up/Down for history, Tab for autocomplete.
` },
            }}
          }},
          etc: { type: "dir", name: "etc", children: {
            motd: { type: "file", name: "motd", data: `Welcome ðŸ‘‹  (${nowString()})` }
          }},
          tmp: { type: "dir", name: "tmp", children: {}},
        }
      };
    }

    function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
    function pathJoin(a,b){
      const av = a.split("/").filter(Boolean);
      const bv = b.split("/").filter(Boolean);
      const parts = (a.startsWith("/")? [""] : []).concat(av).concat(bv);
      const out = [];
      for (const p of parts){
        if (p === "" && out.length===0) { out.push(""); continue; }
        if (p === "." || p === "") continue;
        if (p === "..") { if (out.length>1) out.pop(); continue; }
        out.push(p);
      }
      return (out.length===1 && out[0]==="") ? "/" : out.join("/");
    }
    function traverse(vfs, path) {
      const parts = path === "/" ? ["/"] : path.split("/").filter(Boolean);
      let node = vfs;
      if (path === "/") return vfs;
      for (const p of parts){
        if (!node.children || !node.children[p]) return null;
        node = node.children[p];
      }
      return node;
    }
    function ensureDir(vfs, path){
      const parts = path.split("/").filter(Boolean);
      let node = vfs;
      for (const p of parts){
        if (!node.children) node.children = {};
        if (!node.children[p]) node.children[p] = { type: "dir", name: p, children: {} };
        node = node.children[p];
      }
      return node;
    }
    function writeFile(vfs, path, data){
      const parts = path.split("/").filter(Boolean);
      const fname = parts.pop();
      const dir = ensureDir(vfs, "/" + parts.join("/"));
      dir.children[fname] = { type: "file", name: fname, data: String(data) };
    }
    function listDir(node){
      if (!node || node.type!=="dir") return null;
      return Object.keys(node.children).sort().map(k=>({name:k, type: node.children[k].type}));
    }

    // --- CRC32
    function reflectBits(x, width){
      let y = 0;
      for (let i=0;i<width;i++){ y = (y<<1) | (x & 1); x >>>= 1; }
      return y >>> 0;
    }
    function crc32(text, {poly=0x04C11DB7, init=0xFFFFFFFF, xor=0xFFFFFFFF, refin=true, refout=true}={}){
      let reg = init >>> 0;
      for (let i=0;i<text.length;i++){
        let b = text.charCodeAt(i) & 0xFF;
        if (refin) b = reflectBits(b, 8);
        reg ^= (b << 24) >>> 0;
        for (let k=0;k<8;k++){
          const msb = reg & 0x80000000;
          reg = (reg << 1) >>> 0;
          if (msb) reg = (reg ^ poly) >>> 0;
        }
      }
      if (refout) reg = reflectBits(reg, 32);
      return (reg ^ xor) >>> 0;
    }

    // --- Component
    function WebShell(){
      const [lines, setLines] = useState([]);
      const [input, setInput] = useState("");
      const [cwd, setCwd] = useState("/home/guest");
      const [vfs, setVfs] = useState(()=> makeDefaultVFS());
      const [history, setHistory] = useState([]);
      const [histIdx, setHistIdx] = useState(null);
      const [speakBeforeExec, setSpeakBeforeExec] = useState(true);
      const scrollRef = useRef(null);
      const inpRef = useRef(null);
      const voicesRef = useRef([]);

      function speakUS(text){
        return new Promise((resolve)=>{
          if (!("speechSynthesis" in window)) { resolve("no-tts"); return; }
          const u = new SpeechSynthesisUtterance(text);
          const pick = (voicesRef.current||[]).find(v=> v.lang && v.lang.startsWith("en-US"));
          if (pick) u.voice = pick;
          u.lang = "en-US"; u.rate = 1; u.pitch = 1;
          u.onend = ()=> resolve("done");
          u.onerror = ()=> resolve("err");
          window.speechSynthesis.speak(u);
        });
      }

      useEffect(()=>{ scrollRef.current?.scrollTo({top: 999999}); }, [lines]);
      useEffect(()=>{ inpRef.current?.focus(); }, []);
      useEffect(()=>{
        if ("speechSynthesis" in window){
          const load = ()=>{ voicesRef.current = window.speechSynthesis.getVoices(); };
          load();
          window.speechSynthesis.onvoiceschanged = load;
        }
      }, []);

      const prompt = useMemo(()=>`guest@web:${cwd}$`, [cwd]);

      function resolvePath(p){
        if (!p || p === ".") return cwd;
        if (p === "~") return "/home/guest";
        if (p.startsWith("/")) return pathJoin("/", p);
        return pathJoin(cwd, p);
      }

      async function runCommand(line){
        if (!line.trim()) return;
        setLines(prev => prev.concat(`${prompt} ${line}`));

        const parts = splitArgs(line);
        const cmd = parts[0];
        const argv = parts.slice(1);

        if (cmd === "help") return setLines(prev=> prev.concat("Builtins: help, clear, ls, cd, cat, echo, pwd, whoami, uname, date, calc, crc32"));
        if (cmd === "clear") return setLines([]);
        if (cmd === "date") return setLines(prev=> prev.concat(new Date().toString()));
        if (cmd === "pwd") return setLines(prev=> prev.concat(cwd));
        if (cmd === "whoami") return setLines(prev=> prev.concat("guest"));
        if (cmd === "uname") return setLines(prev=> prev.concat("WebShell 1.0 (browser)"));
        if (cmd === "echo") return setLines(prev=> prev.concat(argv.join(" ")));
        if (cmd === "ls"){
          const target = argv[0] ? resolvePath(argv[0]) : cwd;
          const node = traverse(vfs, target);
          if (!node) return setLines(prev=> prev.concat(`ls: ${argv[0]} not found`));
          if (node.type==="file") return setLines(prev=> prev.concat(node.name));
          const entries = listDir(node) || [];
          return setLines(prev=> prev.concat(entries.map(e=> e.type==="dir"? e.name+"/": e.name).join("  ")));
        }
        if (cmd === "cd"){
          const p = argv[0] ? resolvePath(argv[0]) : "/home/guest";
          const node = traverse(vfs, p);
          if (!node || node.type!=="dir") return setLines(prev=> prev.concat(`cd: ${argv[0]}: not a directory`));
          setCwd(p);
          return;
        }
        if (cmd === "cat"){
          const p = resolvePath(argv[0]);
          const n = traverse(vfs, p);
          if (!n) return setLines(prev=> prev.concat(`cat: ${argv[0]} not found`));
          if (n.type!=="file") return setLines(prev=> prev.concat("cat: is a directory"));
          return setLines(prev=> prev.concat(n.data));
        }
        if (cmd === "calc"){
          const expr = argv.join(" ").replace(/\^/g, "**");
          try{ setLines(prev=> prev.concat(String(Function(`return (${expr})`)()))); }
          catch(e){ setLines(prev=> prev.concat("calc error")); }
          return;
        }
        if (cmd === "crc32"){
          const txt = argv.join(" ");
          const val = crc32(txt);
          return setLines(prev=> prev.concat(toHex(val)));
        }
        setLines(prev=> prev.concat(`command not found: ${cmd}`));
      }

      async function onKeyDown(e){
        if (e.key === "Enter"){
          e.preventDefault();
          const cmd = input;
          setHistory(prev=> prev.concat(cmd).slice(-500));
          setHistIdx(null);
          setInput("");
          try { if (speakBeforeExec) { await speakUS(cmd); } } catch(_) {}
          await runCommand(cmd);
        }
        if (e.key === "ArrowUp"){ e.preventDefault(); if (history.length===0) return; const idx = histIdx===null? history.length-1 : clamp(histIdx-1, 0, history.length-1); setHistIdx(idx); setInput(history[idx]); }
        if (e.key === "ArrowDown"){ e.preventDefault(); if (history.length===0){ setInput(""); return; } if (histIdx===null){ setInput(""); return; } const idx = clamp(histIdx+1, 0, history.length); setHistIdx(idx===history.length? null : idx); setInput(idx===history.length? "" : history[idx]); }
      }

      return (
        <div className="min-h-screen bg-slate-900 text-slate-100 flex items-center justify-center p-4">
          <div className="w-full max-w-4xl rounded-2xl shadow-2xl border border-slate-700 bg-slate-950/60 backdrop-blur">
            <div className="flex items-center justify-between px-4 py-2 border-b border-slate-800">
              <div className="flex items-center gap-2">
                <span className="w-3 h-3 rounded-full bg-red-500"/>
                <span className="w-3 h-3 rounded-full bg-yellow-500"/>
                <span className="w-3 h-3 rounded-full bg-green-500"/>
                <span className="font-mono text-sm ml-2 text-slate-300">Web Shell</span>
              </div>
              <div className="text-xs text-slate-400">{nowString()}</div>
            </div>
            <div ref={scrollRef} className="h-[66vh] overflow-auto px-4 py-3 font-mono text-[13px] leading-6">
              {lines.map((l,i)=> <div key={i} className="whitespace-pre-wrap">{l}</div>)}
              <div className="flex items-start gap-2">
                <span className="shrink-0 text-emerald-400">{prompt}</span>
                <input ref={inpRef} value={input} onChange={(e)=> setInput(e.target.value)} onKeyDown={onKeyDown} spellCheck={false} className="bg-transparent outline-none flex-1 caret-emerald-400" />
              </div>
            </div>
            <div className="flex items-center justify-between px-4 py-2 border-t border-slate-800 text-xs text-slate-400">
              <div className="flex items-center gap-4">
                <div>Tip: Up/Down history â€¢ Tab autocomplete â€¢ <kbd className="px-1 py-0.5 bg-slate-800 rounded">clear</kbd> to reset</div>
                <label className="flex items-center gap-1 cursor-pointer select-none">
                  <input type="checkbox" className="accent-emerald-500" checked={speakBeforeExec} onChange={(e)=> setSpeakBeforeExec(e.target.checked)} />
                  <span>Speak before execute (US)</span>
                </label>
              </div>
              <button className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 border border-slate-700" onClick={()=>{ setLines([]); setInput(""); }}>Reset view</button>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<WebShell />);
  </script>
</body>
</html>
