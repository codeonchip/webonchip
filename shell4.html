<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Web Shell</title>
  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-900">

  <div id="root"></div>

  <!-- React and ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Your WebShell code -->
  <script type="text/babel">
    /* paste the full WebShell component code here */
    /* for example: */
    function WebShell() {


import React, {useEffect, useMemo, useRef, useState} from "react";

// --- Small helpers ---------------------------------------------------------
const nowString = () => new Date().toLocaleString();
const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
const toHex = (n, width=8) => "0x" + (n>>>0).toString(16).toUpperCase().padStart(width, "0");
const isHex = (s) => /^0x[0-9a-f]+$/i.test(s);
const parseNum = (s) => isHex(s) ? parseInt(s, 16) : Number(s);

function splitArgs(line) {
  // Quoted args aware splitter: supports "double" and 'single' quotes
  const out = [];
  let cur = ""; let quote = null;
  for (let i=0;i<line.length;i++) {
    const ch = line[i];
    if (quote) {
      if (ch === quote) { quote = null; } else { cur += ch; }
    } else {
      if (ch === '"' || ch === "'") quote = ch;
      else if (ch === " ") { if (cur.length) { out.push(cur); cur = ""; } }
      else cur += ch;
    }
  }
  if (cur.length) out.push(cur);
  return out;
}

function parseFlags(argv) {
  const flags = {}, args = [];
  for (const token of argv) {
    if (token.startsWith("--")) {
      const [k,v] = token.slice(2).split("=");
      flags[k] = v === undefined ? true : v;
    } else args.push(token);
  }
  return {flags, args};
}

// --- Minimal virtual filesystem -------------------------------------------
function makeDefaultVFS() {
  return {
    type: "dir", name: "/", children: {
      home: { type: "dir", name: "home", children: {
        guest: { type: "dir", name: "guest", children: {
          "readme.txt": { type: "file", name: "readme.txt", data:
`Welcome to Web Shell!\n\nTry:\n  help              # list commands\n  ls, cd, cat       # explore this virtual FS\n  calc 1+2*3        # quick calculator\n  crc32 --help      # CRC-32 (customizable)\n  base64 encode hello\n  curl https://example.com\n  uname, whoami, date, pwd\n\nTip: Up/Down for history, Tab for autocomplete.\n` },
        }}
      }},
      etc: { type: "dir", name: "etc", children: {
        motd: { type: "file", name: "motd", data: `Welcome ðŸ‘‹  (${nowString()})` }
      }},
      tmp: { type: "dir", name: "tmp", children: {}},
    }
  };
}

function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

function pathJoin(a,b){
  const av = a.split("/").filter(Boolean);
  const bv = b.split("/").filter(Boolean);
  const parts = (a.startsWith("/")? [""] : []).concat(av).concat(bv);
  const out = [];
  for (const p of parts){
    if (p === "" && out.length===0) { out.push(""); continue; }
    if (p === "." || p === "") continue;
    if (p === "..") { if (out.length>1) out.pop(); continue; }
    out.push(p);
  }
  return (out.length===1 && out[0]==="") ? "/" : out.join("/");
}

function traverse(vfs, path) {
  const parts = path === "/" ? ["/"] : path.split("/").filter(Boolean);
  let node = vfs;
  if (path === "/") return vfs;
  for (const p of parts){
    if (!node.children || !node.children[p]) return null;
    node = node.children[p];
  }
  return node;
}

function ensureDir(vfs, path){
  const parts = path.split("/").filter(Boolean);
  let node = vfs;
  for (const p of parts){
    if (!node.children) node.children = {};
    if (!node.children[p]) node.children[p] = { type: "dir", name: p, children: {} };
    node = node.children[p];
  }
  return node;
}

function writeFile(vfs, path, data){
  const parts = path.split("/").filter(Boolean);
  const fname = parts.pop();
  const dir = ensureDir(vfs, "/" + parts.join("/"));
  dir.children[fname] = { type: "file", name: fname, data: String(data) };
}

function listDir(node){
  if (!node || node.type!=="dir") return null;
  return Object.keys(node.children).sort().map(k=>({name:k, type: node.children[k].type}));
}

// --- CRC32 (configurable) --------------------------------------------------
function reflectBits(x, width){
  let y = 0;
  for (let i=0;i<width;i++){ y = (y<<1) | (x & 1); x >>>= 1; }
  return y >>> 0;
}

function crc32(text, {poly=0x04C11DB7, init=0xFFFFFFFF, xor=0xFFFFFFFF, refin=true, refout=true}={}){
  let reg = init >>> 0;
  for (let i=0;i<text.length;i++){
    let b = text.charCodeAt(i) & 0xFF;
    if (refin) b = reflectBits(b, 8);
    reg ^= (b << 24) >>> 0;
    for (let k=0;k<8;k++){
      const msb = reg & 0x80000000;
      reg = (reg << 1) >>> 0;
      if (msb) reg = (reg ^ poly) >>> 0;
    }
  }
  if (refout) reg = reflectBits(reg, 32);
  return (reg ^ xor) >>> 0;
}

// --- Core terminal component ----------------------------------------------
export default function WebShell(){
  const [lines, setLines] = useState([]); // printed output lines
  const [input, setInput] = useState("");
  const [cwd, setCwd] = useState("/home/guest");
  const [vfs, setVfs] = useState(()=>{
    const saved = localStorage.getItem("webshell_vfs");
    return saved ? JSON.parse(saved) : makeDefaultVFS();
  });
  const [history, setHistory] = useState(()=>{
    const h = localStorage.getItem("webshell_hist");
    return h ? JSON.parse(h) : [];
  });
  const [histIdx, setHistIdx] = useState(null);
  const scrollRef = useRef(null);
  const inpRef = useRef(null);
  const voicesRef = useRef([]);
  const [speakBeforeExec, setSpeakBeforeExec] = useState(true);

  function speakUS(text){
    return new Promise((resolve)=>{
      if (!("speechSynthesis" in window)) { resolve("no-tts"); return; }
      const u = new SpeechSynthesisUtterance(text);
      const pick = (voicesRef.current||[]).find(v=> v.lang && v.lang.startsWith("en-US"));
      if (pick) u.voice = pick;
      u.lang = "en-US";
      u.rate = 1; u.pitch = 1;
      u.onend = ()=> resolve("done");
      u.onerror = ()=> resolve("err");
      window.speechSynthesis.speak(u);
    });
  }

  useEffect(()=>{ localStorage.setItem("webshell_vfs", JSON.stringify(vfs)); }, [vfs]);
  useEffect(()=>{ localStorage.setItem("webshell_hist", JSON.stringify(history)); }, [history]);
  useEffect(()=>{ scrollRef.current?.scrollTo({top: 999999}); }, [lines]);
  useEffect(()=>{ inpRef.current?.focus(); }, []);
  useEffect(()=>{
    if ("speechSynthesis" in window){
      const load = ()=>{ voicesRef.current = window.speechSynthesis.getVoices(); };
      load();
      window.speechSynthesis.onvoiceschanged = load;
    }
  }, []);

  const prompt = useMemo(()=>{
    const user = "guest";
    const host = "web";
    return `${user}@${host}:${cwd}$`;
  }, [cwd]);

  const ctx = useMemo(()=>({
    print: (s)=> setLines(prev=> prev.concat(String(s).split(/\n/g))),
    println: (s)=> setLines(prev=> prev.concat(String(s))),
    setCwd, cwd,
    getNode: (p)=> traverse(vfs, p),
    writeFile: (p,d)=> setVfs(prev=>{ const nv=clone(prev); writeFile(nv, p, d); return nv; }),
    listDir: (p)=> listDir(traverse(vfs, p)),
    vfs, setVfs,
  }), [vfs, cwd]);

  // --- Built-in commands ---------------------------------------------------
  const builtins = useMemo(()=>({
    help(argv){
      const cmds = Object.keys(builtins).sort().join(", ");
      return `Builtins: ${cmds}\n\nExamples:\n  ls -l\n  cd /etc && cat motd\n  calc (3+5)^2/4\n  crc32 --poly=0x6938392D --init=0xFFFFFFFF --xor=0x00000000 --refin=false --refout=false "ABC"\n  base64 encode "hello"\n  curl https://example.com`;
    },
    clear(){ setLines([]); return null; },
    date(){ return new Date().toString(); },
    pwd(){ return cwd; },
    whoami(){ return "guest"; },
    uname(){ return "WebShell 1.0 (browser)"; },
    echo(argv){ return argv.join(" "); },
    ls(argv){
      const {flags, args} = parseFlags(argv);
      const target = args[0] ? resolvePath(args[0]) : cwd;
      const node = traverse(vfs, target);
      if (!node) return `ls: cannot access '${args[0]||""}': No such file or directory`;
      if (node.type === "file") return node.name;
      const entries = listDir(node) || [];
      if (flags.l) {
        return entries.map(e => `${e.type === "dir" ? "d" : "-"} --- ${e.name}`).join("\n");
      }
      return entries.map(e => e.type === "dir" ? e.name+"/" : e.name).join("  ");
    },
    cd(argv){
      const p = argv[0] ? resolvePath(argv[0]) : "/home/guest";
      const node = traverse(vfs, p);
      if (!node) return `cd: ${argv[0]}: No such file or directory`;
      if (node.type !== "dir") return `cd: ${argv[0]}: Not a directory`;
      setCwd(p);
      return null;
    },
    cat(argv){
      if (!argv.length) return "cat: missing operand";
      const p = resolvePath(argv[0]);
      const n = traverse(vfs, p);
      if (!n) return `cat: ${argv[0]}: No such file`;
      if (n.type !== "file") return `cat: ${argv[0]}: Is a directory`;
      return n.data;
    },
    touch(argv){
      if (!argv.length) return "touch: missing file";
      const p = resolvePath(argv[0]);
      ctx.writeFile(p, "");
      return null;
    },
    write(argv){
      // write <path> <content>
      if (argv.length < 2) return "write: usage: write <path> <content>";
      const p = resolvePath(argv[0]);
      ctx.writeFile(p, argv.slice(1).join(" "));
      return null;
    },
    rm(argv){
      if (!argv.length) return "rm: missing file";
      const p = resolvePath(argv[0]);
      setVfs(prev=>{
        const nv = clone(prev);
        const parts = p.split("/").filter(Boolean);
        const name = parts.pop();
        const dir = traverse(nv, "/"+parts.join("/"));
        if (!dir || !dir.children || !dir.children[name]) return prev;
        delete dir.children[name];
        return nv;
      });
      return null;
    },
    mkdir(argv){
      if (!argv.length) return "mkdir: missing dir";
      const p = resolvePath(argv[0]);
      setVfs(prev=>{ const nv = clone(prev); ensureDir(nv, p); return nv; });
      return null;
    },
    base64(argv){
      const {args} = parseFlags(argv);
      if (args.length < 2) return "base64: usage: base64 <encode|decode> <text>";
      const [mode, ...rest] = args;
      const text = rest.join(" ");
      try{
        if (mode === "encode") return btoa(unescape(encodeURIComponent(text)));
        if (mode === "decode") return decodeURIComponent(escape(atob(text)));
        return "base64: unknown mode";
      }catch(e){ return `base64: error: ${e.message}`; }
    },
    calc(argv){
      const expr = argv.join(" ");
      if (!expr) return "calc: usage: calc <expression>";
      // Very basic sanitizer: only numbers + math operators/spaces/parentheses
      const safe = expr.replace(/\^/g, "**");
      if (!/^[-+*/%().\d\s**]+$/.test(safe)) return "calc: invalid characters";
      try {
        // eslint-disable-next-line no-new-func
        const val = Function(`"use strict"; return (${safe});`)();
        return String(val);
      } catch(e){ return `calc: error: ${e.message}`; }
    },
    crc32(argv){
      const {flags, args} = parseFlags(argv);
      if (flags.help) return (
`crc32 [--poly=0x04C11DB7] [--init=0xFFFFFFFF] [--xor=0xFFFFFFFF] [--refin=true] [--refout=true] <text>\nReturns CRC-32 of <text>.`);
      if (!args.length) return "crc32: missing <text>";
      const poly = flags.poly ? parseNum(flags.poly) >>> 0 : 0x04C11DB7;
      const init = flags.init ? parseNum(flags.init) >>> 0 : 0xFFFFFFFF;
      const xor  = flags.xor  ? parseNum(flags.xor)  >>> 0 : 0xFFFFFFFF;
      const refin = flags.refin !== undefined ? String(flags.refin).toLowerCase() === "true" : true;
      const refout= flags.refout!== undefined ? String(flags.refout).toLowerCase()=== "true" : true;
      const txt = args.join(" ");
      const val = crc32(txt, {poly, init, xor, refin, refout});
      return toHex(val);
    },
    hexdump(argv){
      if (!argv.length) return "hexdump: usage: hexdump <text>";
      const bytes = new TextEncoder().encode(argv.join(" "));
      let out = [];
      for (let i=0;i<bytes.length;i+=16){
        const chunk = bytes.slice(i, i+16);
        const hex = Array.from(chunk).map(b=>b.toString(16).padStart(2,'0')).join(' ');
        const ascii = Array.from(chunk).map(b=> (b>=32 && b<=126)? String.fromCharCode(b):'.').join('');
        out.push(i.toString(16).padStart(8,'0')+"  "+hex.padEnd(47,' ')+"  |"+ascii+"|");
      }
      return out.join("\n");
    },
    curl(argv){
      if (!argv.length) return "curl: usage: curl <url>";
      let url = argv[0];
      if (!/^https?:\/\//i.test(url)) url = "https://"+url;
      return fetch(url)
        .then(r=> r.text())
        .then(txt=> txt.slice(0, 8000))
        .catch(e=> `curl: ${e.message} (CORS or network)`);
    },
    history(){
      return history.map((h,i)=>`${i+1}  ${h}`).join("\n");
    },
  }), [cwd, vfs, history]);

  function resolvePath(p){
    if (!p || p === ".") return cwd;
    if (p === "~") return "/home/guest";
    if (p.startsWith("/")) return pathJoin("/", p);
    return pathJoin(cwd, p);
  }

  async function runCommand(line){
    if (!line.trim()) return;
    setLines(prev => prev.concat(`${prompt} ${line}`));

    const parts = splitArgs(line);
    // rudimentary && handling
    const andIdx = parts.indexOf("&&");
    if (andIdx !== -1){
      const left = parts.slice(0, andIdx).join(" ");
      const right= parts.slice(andIdx+1).join(" ");
      await runCommand(left);
      await runCommand(right);
      return;
    }

    const cmd = parts[0];
    const argv = parts.slice(1);
    const fn = builtins[cmd];
    if (!fn){ setLines(prev=>prev.concat(`command not found: ${cmd}`)); return; }
    try{
      const res = fn(argv, ctx);
      const out = res instanceof Promise ? await res : res;
      if (out!==null && out!==undefined && out!=="") ctx.print(out);
    }catch(e){ ctx.print(`error: ${e.message}`); }
  }

  async function onKeyDown(e){
    if (e.key === "Enter"){
      e.preventDefault();
      const cmd = input;
      setHistory(prev=> prev.concat(cmd).slice(-500));
      setHistIdx(null);
      setInput("");
      try{
        if (speakBeforeExec) { await speakUS(cmd); }
      } catch (_) { /* swallow TTS errors and continue */ }
      await runCommand(cmd);
      return;
    }
    if (e.key === "ArrowUp"){
      e.preventDefault();
      if (history.length===0) return;
      const idx = histIdx===null? history.length-1 : clamp(histIdx-1, 0, history.length-1);
      setHistIdx(idx);
      setInput(history[idx]);
      return;
    }
    if (e.key === "ArrowDown"){
      e.preventDefault();
      if (history.length===0){ setInput(""); return; }
      if (histIdx===null){ setInput(""); return; }
      const idx = clamp(histIdx+1, 0, history.length);
      setHistIdx(idx===history.length? null : idx);
      setInput(idx===history.length? "" : history[idx]);
      return;
    }
    if (e.key === "Tab"){
      e.preventDefault();
      // autocomplete commands & current dir entries
      const tokens = splitArgs(input);
      const isCmd = tokens.length<=1;
      const word = tokens[tokens.length-1]||"";
      let candidates = [];
      if (isCmd){ candidates = Object.keys(builtins); }
      else {
        const dir = cwd;
        const entries = listDir(traverse(vfs, dir)) || [];
        candidates = entries.map(e=> e.name + (e.type==='dir'? '/':''));
      }
      const matches = candidates.filter(c=> c.startsWith(word));
      if (matches.length===1){
        tokens[tokens.length-1] = matches[0];
        setInput(tokens.join(" "));
      } else if (matches.length>1){
        setLines(prev=> prev.concat(matches.join("  ")));
      }
      return;
    }
  }

  return (
    <div className="min-h-screen bg-slate-900 text-slate-100 flex items-center justify-center p-4">
      <div className="w-full max-w-4xl rounded-2xl shadow-2xl border border-slate-700 bg-slate-950/60 backdrop-blur">
        <div className="flex items-center justify-between px-4 py-2 border-b border-slate-800">
          <div className="flex items-center gap-2">
            <span className="w-3 h-3 rounded-full bg-red-500"/>
            <span className="w-3 h-3 rounded-full bg-yellow-500"/>
            <span className="w-3 h-3 rounded-full bg-green-500"/>
            <span className="font-mono text-sm ml-2 text-slate-300">Web Shell</span>
          </div>
          <div className="text-xs text-slate-400">{nowString()}</div>
        </div>
        <div ref={scrollRef} className="h-[66vh] overflow-auto px-4 py-3 font-mono text-[13px] leading-6">
          {lines.map((l,i)=> (
            <div key={i} className="whitespace-pre-wrap">{l}</div>
          ))}
          <div className="flex items-start gap-2">
            <span className="shrink-0 text-emerald-400">{prompt}</span>
            <input
              ref={inpRef}
              value={input}
              onChange={(e)=> setInput(e.target.value)}
              onKeyDown={onKeyDown}
              spellCheck={false}
              className="bg-transparent outline-none flex-1 caret-emerald-400"
              aria-label="terminal input"
              autoFocus
            />
          </div>
        </div>
        <div className="flex items-center justify-between px-4 py-2 border-t border-slate-800 text-xs text-slate-400">
          <div className="flex items-center gap-4">
            <div>Tip: Up/Down history â€¢ Tab autocomplete â€¢ <kbd className="px-1 py-0.5 bg-slate-800 rounded">clear</kbd> to reset</div>
            <label className="flex items-center gap-1 cursor-pointer select-none">
              <input type="checkbox" className="accent-emerald-500" checked={speakBeforeExec} onChange={(e)=> setSpeakBeforeExec(e.target.checked)} />
              <span>Speak before execute (US)</span>
            </label>
          </div>
          <button
            className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 border border-slate-700"
            onClick={()=>{ setLines([]); setInput(""); }}
          >Reset view</button>
        </div>
          <button
            className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 border border-slate-700"
            onClick={()=>{ setLines([]); setInput(""); }}
          >Reset view</button>
        </div>
      </div>
    </div>
  );
}


 }

    ReactDOM.createRoot(document.getElementById("root")).render(<WebShell />);
  </script>
</body>
</html>
