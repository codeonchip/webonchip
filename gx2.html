<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>3D Multi‑Surface Grapher — z = f(x, y)</title>
<style>
  :root { --bg:#0f172a; --panel:#0b1020; --fg:#e2e8f0; --muted:#94a3b8; --accent:#38bdf8; --line:#1e293b; }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--fg)}
  header{padding:14px 16px;border-bottom:1px solid #0b1220;background:var(--panel);position:sticky;top:0;z-index:2}
  h1{margin:0 0 6px;font-size:18px;color:#e5f3ff}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  input,select,button,textarea{background:#0b1220;color:var(--fg);border:1px solid var(--line);border-radius:10px;padding:8px 10px;font-size:14px}
  input:focus,select:focus,textarea:focus{outline:2px solid #124d74;border-color:#0ea5e9}
  button{cursor:pointer;background:#0ea5e9;border-color:#0ea5e9;color:#071422;font-weight:600}
  button.secondary{background:transparent;border-color:#334155;color:#cbd5e1}
  main{display:grid;grid-template-columns:380px 1fr;min-height:calc(100dvh - 72px)}
  aside{border-right:1px solid #0b1220;padding:14px}
  .group{margin-bottom:12px}
  .hint{font-size:12px;color:#9fb3c8;line-height:1.35}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  textarea{width:100%;min-height:110px;resize:vertical;line-height:1.4}
  #errors{color:#fca5a5;white-space:pre-wrap;font-size:12px;min-height:1.2em}
  #panel{display:grid;grid-template-rows: 1fr auto auto}
  canvas{width:100%;height:100%;display:block;background:#060b16}
  footer{padding:10px 14px;border-top:1px solid #0b1220;color:#8daac1;font-size:12px}
  .toggle{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label.chk{display:flex;align-items:center;gap:6px;font-size:13px;color:#cdd9e5}
  code.kbd{padding:0 6px;border:1px solid #334155;border-radius:6px;font-size:12px;color:#a8c5db}
  #legend{display:flex;flex-wrap:wrap;gap:8px;padding:8px 12px;border-top:1px solid #0b1220;background:#0a0f1a}
  .legend-item{display:flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid #1f2a3b;border-radius:10px;cursor:pointer;user-select:none}
  .swatch{width:14px;height:14px;border-radius:3px;border:1px solid #0b1220}
  .legend-off{opacity:0.45;filter:saturate(60%)}
  #readout{padding:6px 10px;font-size:12px;color:#cde2ff}
  @media (max-width:1000px){ main{grid-template-columns:1fr} aside{border-right:none;border-bottom:1px solid #0b1220} }
</style>
</head>
<body>
<header>
  <h1>3D Multi‑Surface Grapher — z = f(x, y)</h1>
  <div class="row">
    <select id="preset">
      <option value="">Presets…</option>
      <option>f: sin(r)/r\ng: sin(x)*cos(y)</option>
      <option>f: exp(-(x^2+y^2))\ng: 0.5*(x^2 - y^2)</option>
      <option>f: sin(x^2 + y^2)\ng: (sin(x)+sin(y))/(1+0.1*(x^2+y^2))</option>
      <option>f: 0.5*sin(2*x) + 0.5*cos(2*y)\ng: atan2(y,x)</option>
    </select>
    <button id="plot">Plot</button>
    <button id="reset" class="secondary">Reset View</button>
    <button id="save" class="secondary">Save PNG</button>
    <span id="errors"></span>
  </div>
</header>

<main>
  <aside>
    <div class="group">
      <label for="exprs">Surfaces (one per line, optional <code>label: expr(x,y)</code>)</label>
      <textarea id="exprs" placeholder="Examples:\nf: sin(r)/r\ng: sin(x)*cos(y)\nexp(-(x^2+y^2))"></textarea>
    </div>

    <div class="group grid-2">
      <label>x-min <input id="xmin" type="number" step="any" value="-6.28"></label>
      <label>x-max <input id="xmax" type="number" step="any" value="6.28"></label>
    </div>
    <div class="group grid-2">
      <label>y-min <input id="ymin" type="number" step="any" value="-6.28"></label>
      <label>y-max <input id="ymax" type="number" step="any" value="6.28"></label>
    </div>

    <div class="group grid-3">
      <label>Resolution <input id="res" type="number" min="16" max="256" value="96"></label>
      <label>Auto Z <select id="autoz"><option>true</option><option>false</option></select></label>
      <label>FOV° <input id="fov" type="number" min="20" max="100" value="55"></label>
    </div>

    <div class="group grid-2" id="zrange" style="display:none">
      <label>z-min <input id="zmin" type="number" step="any" value="-2"></label>
      <label>z-max <input id="zmax" type="number" step="any" value="2"></label>
    </div>

    <div class="group toggle">
      <label class="chk"><input id="wire" type="checkbox"> Wireframe</label>
      <label class="chk"><input id="axes" type="checkbox" checked> Axes</label>
      <label class="chk"><input id="color" type="checkbox" checked> Height colors</label>
      <label class="chk"><input id="smooth" type="checkbox" checked> Smooth shading</label>
      <label class="chk"><input id="contours" type="checkbox" checked> Contours</label>
      <label class="chk">Levels <input id="levels" type="number" min="2" max="24" value="10" style="width:72px"></label>
    </div>

    <div class="group">
      <button id="apply">Apply Range</button>
    </div>

    <div class="group">
      <div class="hint">
        <strong>Syntax</strong><br/>
        • Operators: <code>+ - * / % ^</code> (use <code>^</code> for power)<br/>
        • Functions: sin, cos, tan, asin, acos, atan, ln(=log), log10, exp, sqrt, abs, floor, ceil, round, min, max, pow, sign<br/>
        • Built-ins: <code>r = sqrt(x*x + y*y)</code>, <code>theta = atan2(y, x)</code>, constants <code>pi</code>, <code>e</code><br/>
        • Examples: <code>sin(r)/r</code>, <code>sin(x)*cos(y)</code>, <code>exp(-(x^2+y^2))</code>
      </div>
    </div>
  </aside>

  <section id="panel">
    <canvas id="gl"></canvas>
    <div id="legend"></div>
    <div id="readout">Hover to probe a point. Left‑drag: rotate • Wheel: zoom • Right‑drag / Shift‑drag: pan • Double‑click: reset</div>
    <footer>
      Extras: Multiple surfaces, contour lines, point picking (hover), and PNG export via “Save PNG”.
    </footer>
  </section>
</main>

<script>
(() => {
  // —— DOM
  const glCanvas = document.getElementById('gl');
  const presetSel= document.getElementById('preset');
  const plotBtn  = document.getElementById('plot');
  const resetBtn = document.getElementById('reset');
  const saveBtn  = document.getElementById('save');
  const applyBtn = document.getElementById('apply');
  const errSpan  = document.getElementById('errors');
  const legendDiv= document.getElementById('legend');
  const readout  = document.getElementById('readout');
  const exprsTA  = document.getElementById('exprs');
  const xminI=document.getElementById('xmin'); const xmaxI=document.getElementById('xmax');
  const yminI=document.getElementById('ymin'); const ymaxI=document.getElementById('ymax');
  const resI = document.getElementById('res');
  const autozSel=document.getElementById('autoz');
  const zminI=document.getElementById('zmin'); const zmaxI=document.getElementById('zmax');
  const zrangeDiv=document.getElementById('zrange');
  const wireChk=document.getElementById('wire');
  const axesChk=document.getElementById('axes');
  const colorChk=document.getElementById('color');
  const smoothChk=document.getElementById('smooth');
  const contoursChk=document.getElementById('contours');
  const levelsI=document.getElementById('levels');
  const fovI=document.getElementById('fov');

  // —— GL
  const gl = glCanvas.getContext('webgl');
  if (!gl){ errSpan.textContent = "Your browser doesn't support WebGL."; return; }
  gl.getExtension('OES_element_index_uint');

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = glCanvas.getBoundingClientRect();
    glCanvas.width = Math.floor(rect.width*dpr);
    const h = Math.max(300, window.innerHeight - document.querySelector('header').offsetHeight - 160);
    glCanvas.height= Math.floor(h*dpr);
    gl.viewport(0,0,glCanvas.width, glCanvas.height);
    glCanvas.style.height = Math.floor(glCanvas.height/dpr) + 'px';
    draw();
  }
  window.addEventListener('resize', fitCanvas);

  // —— Shaders
  const VS = `
  attribute vec3 aPos; // centered positions for current surface
  attribute vec3 aNormal;
  attribute float aZGlobal; // original (uncentered) Z used for colormap mapping across all surfaces
  uniform mat4 uMVP;
  uniform mat3 uNrmMat;
  varying vec3 vNormal;
  varying float vZg;
  void main(){
    gl_Position = uMVP * vec4(aPos,1.0);
    vNormal = normalize(uNrmMat * aNormal);
    vZg = aZGlobal;
  }`;
  const FS = `
  precision mediump float;
  varying vec3 vNormal;
  varying float vZg;
  uniform vec3 uLightDir;
  uniform float uZMin, uZMax;
  uniform bool uHeightColors;
  uniform bool uSmooth;
  uniform vec3 uBaseColor; // per-surface base color for wire/flat
  // turbo-like colormap
  vec3 turbo(float t){
    t = clamp(t,0.0,1.0);
    return vec3(
      0.1357 + 4.6154*t - 42.6603*t*t + 132.1311*t*t*t - 152.9424*t*t*t*t + 63.4984*t*t*t*t*t,
      0.0914 + 2.9440*t + 4.9119*t*t - 14.1850*t*t*t + 4.8055*t*t*t*t + 2.4761*t*t*t*t*t,
      0.1067 + 9.4944*t - 31.5402*t*t + 48.0810*t*t*t - 23.3417*t*t*t*t
    );
  }
  void main(){
    vec3 N = normalize(vNormal);
    float diff = max(dot(N, normalize(uLightDir)), 0.0);
    float t = (vZg - uZMin) / max(1e-9, (uZMax - uZMin));
    vec3 base = uHeightColors ? turbo(t) : uBaseColor;
    float shade = uSmooth ? (0.25 + 0.75*diff) : 1.0;
    gl_FragColor = vec4(base * shade, 1.0);
  }`;

  function compile(type, src){ const sh=gl.createShader(type); gl.shaderSource(sh,src); gl.compileShader(sh); if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(sh)); return sh; }
  function link(vs,fs){ const p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
  const program = link(compile(gl.VERTEX_SHADER,VS), compile(gl.FRAGMENT_SHADER,FS));
  gl.useProgram(program);

  // locations
  const aPos = gl.getAttribLocation(program,'aPos');
  const aNormal = gl.getAttribLocation(program,'aNormal');
  const aZGlobal = gl.getAttribLocation(program,'aZGlobal');
  const uMVP = gl.getUniformLocation(program,'uMVP');
  const uNrmMat = gl.getUniformLocation(program,'uNrmMat');
  const uLightDir = gl.getUniformLocation(program,'uLightDir');
  const uZMin = gl.getUniformLocation(program,'uZMin');
  const uZMax = gl.getUniformLocation(program,'uZMax');
  const uHeightColors = gl.getUniformLocation(program,'uHeightColors');
  const uSmooth = gl.getUniformLocation(program,'uSmooth');
  const uBaseColor = gl.getUniformLocation(program,'uBaseColor');

  // —— math (tiny mats)
  function mat4Mul(a,b){ const o=new Array(16); for(let r=0;r<4;r++) for(let c=0;c<4;c++){ o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c]; } return o; }
  function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
  function mat4Translate(tx,ty,tz){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1]; }
  function mat4Scale(sx,sy,sz){ return [sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1]; }
  function mat4RotX(a){ const c=Math.cos(a),s=Math.sin(a); return [1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]; }
  function mat4RotY(a){ const c=Math.cos(a),s=Math.sin(a); return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]; }
  function perspective(fovy,aspect,near,far){ const f=1/Math.tan((fovy*Math.PI/180)/2), nf=1/(near-far); return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]; }
  function mat3FromMat4(m){ return [m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]; }

  // —— camera
  let yaw=0.7, pitch=0.6, dist=10, panX=0, panY=0;
  let center=[0,0,0];
  let zMin=-1, zMax=1; // global across all surfaces for colormap

  // —— palette
  const palette = [
    [0.22,0.74,0.97], [0.96,0.45,0.71], [0.64,0.90,0.21], [0.96,0.62,0.11], [0.75,0.52,0.99],
    [0.20,0.83,0.60], [0.98,0.44,0.52], [0.38,0.65,0.98], [0.99,0.83,0.30], [0.13,0.83,0.93]
  ];

  // —— compiler (safe-ish)
  const allowed = new Set(["sin","cos","tan","asin","acos","atan","log","log10","exp","sqrt","abs","floor","ceil","round","min","max","pow","sign","x","y","r","theta","pi","e","Math"]);
  const forbidden = ["constructor","__proto__","prototype","window","document","self","globalthis","function","eval","import","class","=>","fetch","XML"];
  function sanitize(expr){
    const raw = expr.trim(); if(!raw) throw new Error("Empty expression.");
    const low = raw.toLowerCase(); if(forbidden.some(k=>low.includes(k))) throw new Error("Expression contains forbidden keyword.");
    let s = raw.replace(/\^/g,"**").replace(/\bln\s*\(/gi,"log(");
    if (/[`"';]/.test(s)) throw new Error("Avoid quotes/semicolons.");
    const ids = s.match(/[A-Za-z_]\w*/g) || [];
    for(const id of ids){ if(!allowed.has(id)){ if(id==="E"||id==="PI") continue; if(!(id==="x"||id==="y"||id==="r"||id==="theta")) throw new Error("Unknown identifier: "+id); } }
    return s;
  }
  function compile(expr){
    const s = sanitize(expr);
    const src = `with (Math) { const pi=PI, e=E; return function(x,y){ const r=hypot(x,y); const theta=atan2(y,x); return (${s}); } }`;
    const fn = new Function(src)(); fn(0,0); return fn;
  }

  // —— surfaces state
  let ranges = { xmin:-2*Math.PI, xmax:2*Math.PI, ymin:-2*Math.PI, ymax:2*Math.PI };
  let res = 96;
  let surfaces = []; // [{label, color:[r,g,b], fn, buffers:{pos,nrm,idx,lines,contLines}, counts:{tri,line,cont}, centerZOffset}]

  // —— buffers per-surface
  function buildSurfaceForFn(fn, color){
    const nx = res, ny = res;
    const xmin=ranges.xmin, xmax=ranges.xmax, ymin=ranges.ymin, ymax=ranges.ymax;
    const dx=(xmax-xmin)/nx, dy=(ymax-ymin)/ny;
    const V = new Float32Array((nx+1)*(ny+1)*3);
    const N = new Float32Array((nx+1)*(ny+1)*3);
    const Zg= new Float32Array((nx+1)*(ny+1)); // global Z for colormap

    let localZmin= Infinity, localZmax= -Infinity;
    function idx(i,j){ return j*(nx+1)+i; }

    // sample
    for(let j=0;j<=ny;j++){
      const y = ymin + j*dy;
      for(let i=0;i<=nx;i++){
        const x = xmin + i*dx;
        let z = fn(x,y);
        if(!isFinite(z)) z = NaN;
        const k = idx(i,j);
        V[3*k+0]=x; V[3*k+1]=y; V[3*k+2]=z;
        Zg[k]=z;
        if(isFinite(z)){ if(z<localZmin) localZmin=z; if(z>localZmax) localZmax=z; }
      }
    }

    return { V, N, Zg, nx, ny, localZmin, localZmax, color, fn };
  }

  function computeNormals(s){
    const {V,N,nx,ny} = s; const xmin=ranges.xmin, xmax=ranges.xmax, ymin=ranges.ymin, ymax=ranges.ymax;
    const dx=(xmax-xmin)/nx, dy=(ymax-ymin)/ny;
    function idx(i,j){ return j*(nx+1)+i; }
    for(let j=0;j<=ny;j++){
      for(let i=0;i<=nx;i++){
        const k = idx(i,j);
        const zc = V[3*k+2];
        let zx1 = V[3*idx(Math.min(nx,i+1),j)+2];
        let zx0 = V[3*idx(Math.max(0,i-1),j)+2];
        let zy1 = V[3*idx(i,Math.min(ny,j+1))+2];
        let zy0 = V[3*idx(i,Math.max(0,j-1))+2];
        if(!isFinite(zx1)) zx1 = zc; if(!isFinite(zx0)) zx0 = zc; if(!isFinite(zy1)) zy1 = zc; if(!isFinite(zy0)) zy0 = zc;
        const gx = (zx1 - zx0)/(2*dx); const gy = (zy1 - zy0)/(2*dy);
        let nxv=-gx, nyv=-gy, nzv=1.0; const inv = 1/Math.hypot(nxv,nyv,nzv);
        N[3*k+0]=nxv*inv; N[3*k+1]=nyv*inv; N[3*k+2]=nzv*inv;
      }
    }
  }

  function centerVertices(s, center){
    const {V} = s; const C = new Float32Array(V.length);
    for(let i=0;i<V.length;i+=3){ C[i]=V[i]-center[0]; C[i+1]=V[i+1]-center[1]; C[i+2]=V[i+2]-center[2]; }
    s.Vc = C; // centered positions used for draw
  }

  function buildIndicesAndLines(s){
    const {nx,ny} = s;
    // strips indices
    const strips=[]; for(let j=0;j<ny;j++){ if(j>0) strips.push(j*(nx+1)); for(let i=0;i<=nx;i++){ strips.push(j*(nx+1)+i,(j+1)*(nx+1)+i); } if(j<ny-1) strips.push((j+1)*(nx+1)+nx); }
    s.I = new Uint32Array(strips); s.triCount = s.I.length;
    // grid lines
    const lines=[]; function idx(i,j){return j*(nx+1)+i;}
    for(let j=0;j<=ny;j++){ for(let i=0;i<nx;i++){ lines.push(idx(i,j), idx(i+1,j)); } }
    for(let i=0;i<=nx;i++){ for(let j=0;j<ny;j++){ lines.push(idx(i,j), idx(i,j+1)); } }
    s.L = new Uint32Array(lines); s.lineCount = s.L.length;
  }

  // contour generation via marching squares per surface, projected as lines
  function buildContours(s, levels){
    const {nx,ny,V} = s; const xmin=ranges.xmin, xmax=ranges.xmax, ymin=ranges.ymin, ymax=ranges.ymax;
    const dx=(xmax-xmin)/nx, dy=(ymax-ymin)/ny;
    const Z = new Array((nx+1)*(ny+1)); for(let j=0;j<=ny;j++) for(let i=0;i<=nx;i++){ Z[j*(nx+1)+i] = V[3*(j*(nx+1)+i)+2]; }
    const zmin = zMin, zmax = zMax; const segs=[];
    const levelsArr=[]; for(let k=0;k<levels;k++){ levelsArr.push(zmin + (k/(levels-1))*(zmax-zmin)); }
    function isoCell(i,j,z0){
      const x0=xmin+i*dx, y0=ymin+j*dy;
      const z00 = Z[j*(nx+1)+i], z10=Z[j*(nx+1)+i+1], z01=Z[(j+1)*(nx+1)+i], z11=Z[(j+1)*(nx+1)+i+1];
      function interp(a,b,ta,tb){ const t=(z0-ta)/((tb-ta)||1e-9); return a + t*(b-a); }
      const pts=[]; // up to 4 intersections
      // edges: (x,y) positions on original plane, we will compute z from original V too
      if( (z00-z0)*(z10-z0) <= 0 ) pts.push([interp(x0,x0+dx,z00,z10), y0]); // bottom
      if( (z10-z0)*(z11-z0) <= 0 ) pts.push([x0+dx, interp(y0,y0+dy,z10,z11)]); // right
      if( (z11-z0)*(z01-z0) <= 0 ) pts.push([interp(x0+dx,x0,z11,z01), y0+dy]); // top
      if( (z01-z0)*(z00-z0) <= 0 ) pts.push([x0, interp(y0+dy,y0,z01,z00)]); // left
      if(pts.length===2){
        // compute actual z on surface (close to z0), then center them later
        segs.push(pts);
      }
    }
    for(const z0 of levelsArr){ for(let j=0;j<ny;j++){ for(let i=0;i<nx;i++){ isoCell(i,j,z0); } } }
    // convert to Float32 in centered coords (z from fn)
    const out=[]; for(const seg of segs){ for(const p of seg){ const x=p[0], y=p[1]; let z=s.fn(x,y); if(!isFinite(z)) z = z0; out.push(x, y, z); } }
    s.C = new Float32Array(out); s.contCount = out.length/3; // drawn as GL.LINES
  }

  function uploadSurface(s){
    s.posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, s.posBuf); gl.bufferData(gl.ARRAY_BUFFER, s.Vc, gl.STATIC_DRAW);
    s.nrmBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, s.nrmBuf); gl.bufferData(gl.ARRAY_BUFFER, s.N, gl.STATIC_DRAW);
    s.zgBuf  = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, s.zgBuf); gl.bufferData(gl.ARRAY_BUFFER, s.Zg, gl.STATIC_DRAW);
    s.idxBuf = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s.idxBuf); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, s.I, gl.STATIC_DRAW);
    s.lineBuf= gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s.lineBuf); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, s.L, gl.STATIC_DRAW);
    if (s.C){ s.contBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, s.contBuf); gl.bufferData(gl.ARRAY_BUFFER, s.C, gl.STATIC_DRAW); }
  }

  // —— legend
  function buildLegend(){
    legendDiv.innerHTML='';
    surfaces.forEach((s,idx)=>{
      const item=document.createElement('div'); item.className='legend-item'+(s.visible? '':' legend-off'); item.title='Click to toggle';
      const sw=document.createElement('span'); sw.className='swatch'; sw.style.background=`rgb(${s.color[0]*255},${s.color[1]*255},${s.color[2]*255})`;
      const txt=document.createElement('span'); txt.textContent=`${s.label}: ${s.expr}`;
      item.appendChild(sw); item.appendChild(txt);
      item.addEventListener('click',()=>{ s.visible=!s.visible; item.className='legend-item'+(s.visible? '':' legend-off'); draw(); });
      legendDiv.appendChild(item);
    });
  }

  // —— camera controls
  let dragging=false, panMode=false, lastX=0, lastY=0;
  glCanvas.addEventListener('mousedown', (e)=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; panMode=(e.button===2)||e.shiftKey; });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
    if(panMode){ const scale=dist/500; panX+=dx*scale; panY-=dy*scale; } else { yaw+=dx*0.01; pitch+=dy*0.01; const lim=Math.PI/2-0.05; if(pitch>lim)pitch=lim; if(pitch<-lim)pitch=-lim; }
    draw();
  });
  glCanvas.addEventListener('wheel',(e)=>{ e.preventDefault(); const s=(e.deltaY<0)?0.9:1.1; dist=Math.max(0.5,Math.min(1e6,dist*s)); draw(); }, {passive:false});
  glCanvas.addEventListener('dblclick',()=>{ yaw=0.7; pitch=0.6; panX=0; panY=0; dist=0.9*Math.max(ranges.xmax-ranges.xmin, ranges.ymax-ranges.ymin, zMax-zMin); draw(); });
  glCanvas.addEventListener('contextmenu', e=>e.preventDefault());

  // —— MVP
  function computeMats(){
    const aspect = glCanvas.width/glCanvas.height;
    const proj = perspective(parseFloat(fovI.value), aspect, 0.1, 2000);
    const view = mat4Mul(mat4Translate(0,0,-dist), mat4Translate(panX, panY, 0));
    const rot  = mat4Mul(mat4RotY(yaw), mat4RotX(pitch));
    const mv   = mat4Mul(view, rot);
    return { mvp: mat4Mul(proj, mv), nrm: mat3FromMat4(rot) };
  }

  // —— drawing
  function draw(){
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.03,0.06,0.12,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    if(!surfaces.length) return;
    const {mvp,nrm} = computeMats();
    gl.useProgram(program);
    gl.uniformMatrix4fv(uMVP,false,new Float32Array(mvp));
    gl.uniformMatrix3fv(uNrmMat,false,new Float32Array(nrm));
    gl.uniform3f(uLightDir, 0.6,0.7,0.5);
    gl.uniform1f(uZMin, zMin); gl.uniform1f(uZMax, zMax);
    gl.uniform1i(uHeightColors, colorChk.checked?1:0);
    gl.uniform1i(uSmooth, smoothChk.checked?1:0);

    for(const s of surfaces){ if(!s.visible) continue;
      gl.bindBuffer(gl.ARRAY_BUFFER, s.posBuf); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
      gl.bindBuffer(gl.ARRAY_BUFFER, s.nrmBuf); gl.enableVertexAttribArray(aNormal); gl.vertexAttribPointer(aNormal,3,gl.FLOAT,false,0,0);
      gl.bindBuffer(gl.ARRAY_BUFFER, s.zgBuf);  gl.enableVertexAttribArray(aZGlobal); gl.vertexAttribPointer(aZGlobal,1,gl.FLOAT,false,0,0);
      gl.uniform3f(uBaseColor, s.color[0], s.color[1], s.color[2]);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s.idxBuf); gl.drawElements(gl.TRIANGLE_STRIP, s.triCount, gl.UNSIGNED_INT, 0);

      if(wireChk.checked){ gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s.lineBuf); gl.drawElements(gl.LINES, s.lineCount, gl.UNSIGNED_INT, 0); }
      if(contoursChk.checked && s.contBuf){ gl.bindBuffer(gl.ARRAY_BUFFER, s.contBuf); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0); gl.disableVertexAttribArray(aNormal); gl.disableVertexAttribArray(aZGlobal); gl.lineWidth(1); gl.drawArrays(gl.LINES, 0, s.contCount); }
    }

    if(axesChk.checked){ // simple axes in model space length from ranges
      const spanX = (ranges.xmax-ranges.xmin), spanY=(ranges.ymax-ranges.ymin), spanZ=(zMax - zMin);
      const ax = new Float32Array([
        -spanX/2,0,0, spanX/2,0,0,
         0,-spanY/2,0, 0,spanY/2,0,
         0,0,-spanZ/2, 0,0,spanZ/2
      ]);
      const tmp=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,tmp); gl.bufferData(gl.ARRAY_BUFFER,ax,gl.STREAM_DRAW);
      gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0); gl.disableVertexAttribArray(aNormal); gl.disableVertexAttribArray(aZGlobal);
      gl.drawArrays(gl.LINES,0,6);
      gl.deleteBuffer(tmp);
    }
  }

  // —— rebuild pipeline
  function parseDefs(text){
    const lines=text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean); if(!lines.length) throw new Error('Enter at least one surface.');
    const defs=[]; let auto=1; for(const line of lines){ const m=line.match(/^([^:]+):(.+)$/); if(m){ defs.push({label:m[1].trim(), expr:m[2].trim()}); } else { defs.push({label:`f${auto++}`, expr:line}); } }
    return defs;
  }

  function rebuild(){
    try{
      const nx = Math.max(16, Math.min(256, parseInt(resI.value)||96)); res=nx;
      const xmin=Number(xminI.value), xmax=Number(xmaxI.value), ymin=Number(yminI.value), ymax=Number(ymaxI.value);
      if(!(isFinite(xmin)&&isFinite(xmax)&&xmax>xmin)) throw new Error('Invalid x-range');
      if(!(isFinite(ymin)&&isFinite(ymax)&&ymax>ymin)) throw new Error('Invalid y-range');
      ranges={xmin,xmax,ymin,ymax};

      const defs = parseDefs(exprsTA.value);
      // compile
      const compiled = defs.map(d=>({ label:d.label, expr:d.expr, fn:compile(d.expr) }));

      // build all surfaces, get global zMin/zMax
      const temp=[]; let gmin=Infinity, gmax=-Infinity;
      compiled.forEach((c,i)=>{ const s=buildSurfaceForFn(c.fn, palette[i%palette.length]); s.label=c.label; s.expr=c.expr; temp.push(s); if(isFinite(s.localZmin)&&s.localZmin<gmin) gmin=s.localZmin; if(isFinite(s.localZmax)&&s.localZmax>gmax) gmax=s.localZmax; });
      if (autozSel.value === 'true'){ zMin = (gmin===Infinity? -1: gmin); zMax = (gmax===-Infinity? 1: gmax); if(zMax-zMin<1e-6){ zMin-=1; zMax+=1; } zminI.value=zMin.toFixed(4); zmaxI.value=zMax.toFixed(4); } else { zMin=Number(zminI.value); zMax=Number(zmaxI.value); }

      // common center by ranges mid + z mid
      center=[ (xmin+xmax)/2, (ymin+ymax)/2, (zMin+zMax)/2 ];

      temp.forEach(s=>{ computeNormals(s); centerVertices(s, center); buildIndicesAndLines(s); if(contoursChk.checked){ buildContours(s, Math.max(2, Math.min(24, parseInt(levelsI.value)||10)); } });

      // upload
      surfaces = temp.map(s=>({ ...s, visible:true }));
      surfaces.forEach(uploadSurface);

      buildLegend();
      dist = 0.9*Math.max(ranges.xmax-ranges.xmin, ranges.ymax-ranges.ymin, zMax-zMin);
      errSpan.textContent='';
      draw();
    } catch(e){ errSpan.textContent = e.message || String(e); }
  }

  // —— point picking (hover): project vertices to screen and find nearest
  function projectPoint(x,y,z){
    const {mvp} = computeMats(); const m = mvp;
    const X = x, Y=y, Z=z;
    const clipX = X*m[0]+Y*m[4]+Z*m[8] + m[12];
    const clipY = X*m[1]+Y*m[5]+Z*m[9] + m[13];
    const clipZ = X*m[2]+Y*m[6]+Z*m[10]+ m[14];
    const clipW = X*m[3]+Y*m[7]+Z*m[11]+ m[15];
    if (clipW===0) return null; const ndcX=clipX/clipW, ndcY=clipY/clipW, ndcZ=clipZ/clipW;
    const sx = (ndcX*0.5+0.5)*glCanvas.width, sy=(1-(ndcY*0.5+0.5))*glCanvas.height; return {sx,sy,ndcZ};
  }

  glCanvas.addEventListener('mousemove', (e)=>{
    if (!surfaces.length) { readout.textContent=''; return; }
    const rect = glCanvas.getBoundingClientRect();
    const mx = (e.clientX-rect.left) * (glCanvas.width/rect.width);
    const my = (e.clientY-rect.top)  * (glCanvas.height/rect.height);
    let best=null, bestDist=12; // px threshold
    for(const s of surfaces){ if(!s.visible) continue; const V = s.Vc; for(let i=0;i<V.length;i+=3){ const pr=projectPoint(V[i],V[i+1],V[i+2]); if(!pr) continue; const dx=pr.sx-mx, dy=pr.sy-my; const d=Math.hypot(dx,dy); if(d<bestDist){ bestDist=d; best={ x:V[i]+center[0], y:V[i+1]+center[1], z:V[i+2]+center[2] }; } } }
    if(best){ readout.textContent = `x=${best.x.toFixed(4)}  y=${best.y.toFixed(4)}  z=${best.z.toFixed(4)}`; } else { readout.textContent=''; }
  });

  // —— controls
  plotBtn.addEventListener('click', rebuild);
  applyBtn.addEventListener('click', rebuild);
  resetBtn.addEventListener('click', ()=>{ yaw=0.7; pitch=0.6; panX=0; panY=0; dist=0.9*Math.max(ranges.xmax-ranges.xmin, ranges.ymax-ranges.ymin, zMax-zMin); draw(); });
  saveBtn.addEventListener('click', ()=>{ const url=glCanvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='surface.png'; a.click(); });
  presetSel.addEventListener('change', ()=>{ if(!presetSel.value) return; exprsTA.value = presetSel.value; rebuild(); });
  autozSel.addEventListener('change', ()=>{ zrangeDiv.style.display = (autozSel.value==='true') ? 'none':'grid'; });

  // —— init
  exprsTA.value = 'f: sin(r)/r\n g: sin(x)*cos(y)';
  autozSel.value='true'; zrangeDiv.style.display='none';
  fitCanvas(); rebuild();
})();
</script>
</body>
</html>
