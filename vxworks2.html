<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>VxWorks-ish RTOS Simulator — RR, taskDelay, memShow/netShow</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0f172a; --panel:#0b1324; --muted:#94a3b8; --text:#e5e7eb;
    --accent:#38bdf8; --good:#22c55e; --warn:#f59e0b; --bad:#ef4444;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;font-family:ui-monospace,Menlo,Consolas,monospace;background:linear-gradient(180deg,#0f172a 0%,#0b1220 100%);color:var(--text)}
  header{display:flex;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid #1f2937;position:sticky;top:0;background:rgba(15,23,42,.85);backdrop-filter:blur(6px)}
  header h1{margin:0;font-size:18px;letter-spacing:.5px}
  header .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button,input{background:#0b1220;color:var(--text);border:1px solid #243244;padding:6px 10px;border-radius:8px}
  button{cursor:pointer}
  button.primary{border-color:var(--accent);color:#e0f2fe}
  button.warn{border-color:var(--warn);color:#fffbeb}
  main{padding:16px;display:grid;grid-template-columns:1.15fr .85fr;gap:16px}
  @media (max-width:1100px){main{grid-template-columns:1fr}}
  .card{background:var(--panel);border:1px solid #1f2b3a;border-radius:12px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .card h2{margin:0;padding:12px 14px;border-bottom:1px solid #1f2b3a;font-size:14px;color:#cbd5e1}
  .card .body{padding:12px}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:16px}
  @media (max-width:1600px){.grid{grid-template-columns:1fr}}
  table{width:100%;border-collapse:collapse;font-size:12px}
  th,td{border-bottom:1px dashed #243244;padding:6px 8px;text-align:left;color:#cbd5e1}
  th{color:#93c5fd;font-weight:600}
  tr:hover td{background:#0d1730}
  .pill{display:inline-block;padding:2px 6px;border:1px solid #243244;border-radius:999px;font-size:11px;color:#cbd5e1}
  .state-RUNNING{color:#dcfce7;border-color:#16a34a}
  .state-READY{color:#e0f2fe;border-color:#38bdf8}
  .state-PENDED{color:#fde68a;border-color:#f59e0b}
  .state-DELAY{color:#ddd6fe;border-color:#8b5cf6}
  .state-DEAD{color:#fecaca;border-color:#ef4444}
  .term{background:#020617;border:1px solid #1f2937;border-radius:12px;overflow:hidden}
  #termOut{height:340px;overflow:auto;padding:10px 12px;white-space:pre-wrap;background:#030914}
  #promptRow{display:flex;padding:8px 12px;gap:8px;border-top:1px solid #1f2937;align-items:center}
  .tiny{font-size:11px;color:var(--muted)} .kbd{border:1px solid #334155;padding:1px 6px;border-radius:6px;background:#0b1220;font-size:11px}
  code{background:#0b1220;color:#93c5fd;padding:2px 6px;border-radius:6px}
</style>
</head>
<body>
<header>
  <h1>VxWorks-ish RTOS Simulator</h1>
  <div class="controls">
    <span class="tiny">Tick (Hz)</span>
    <input id="hz" type="number" value="10" min="1" max="1000" style="width:90px" />
    <button id="runBtn" class="primary">Run Clock</button>
    <button id="stepTickBtn">Step Tick</button>
    <button id="pauseBtn" class="warn">Pause</button>
    <span class="tiny">Tick:</span><span id="tickLbl" class="kbd">0</span>
    <span class="tiny">RR:</span><span id="rrLbl" class="kbd">off</span>
  </div>
</header>

<main>
  <section class="card">
    <h2>Wind Shell (mimic)</h2>
    <div id="termOut"></div>
    <div id="promptRow">
      <span class="tiny">-&gt;</span>
      <input id="shellInput" type="text" placeholder='try: help | sp demoLoop, 10, 3 | rr on | i | semCreate | taskDelay 1,20 | memShow | netShow' autocomplete="off" />
    </div>
  </section>

  <section class="grid">
    <div class="card">
      <h2>Tasks</h2>
      <div class="body">
        <table id="taskTable">
          <thead><tr><th>TID</th><th>Name</th><th>Prio</th><th>State</th><th>PC</th><th>Info</th></tr></thead>
          <tbody></tbody>
        </table>
        <div class="tiny" style="margin-top:6px">Lower number == higher priority • RR rotates tasks of the same priority</div>
      </div>
    </div>

    <div class="card">
      <h2>Semaphores</h2>
      <div class="body">
        <table id="semTable">
          <thead><tr><th>SID</th><th>Type</th><th>Count</th><th>PendQ</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>Message Queues</h2>
      <div class="body">
        <table id="mqTable">
          <thead><tr><th>QID</th><th>Depth</th><th>Len</th><th>PendRecv</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>Watchdogs</h2>
      <div class="body">
        <table id="wdTable">
          <thead><tr><th>WID</th><th>Expires@</th><th>Active</th><th>Handler</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>
</main>

<script>
/* ======================= Core State ======================= */
const state = {
  tick: 0,
  tasks: [],       // {id,name,prio,state,pc,step,wait,info}
  sems: [],        // {id,type:'bin'|'count',count,pendQ:[]}
  mqs: [],         // {id,depth,buf:[],pendRecv:[]}
  wds: [],         // {id,expiresAt,active,handler,arg}
  nextTid: 1, nextSid: 1, nextQid: 1, nextWid: 1,
  running: false,
  timer: null,
  rr: false,              // round-robin on/off
  rrCursor: {}            // rrCursor[prio] -> index
};
const TaskState = { READY:'READY', RUNNING:'RUNNING', PENDED:'PENDED', DELAY:'DELAY', DEAD:'DEAD' };

const termOut = document.getElementById('termOut');
const inputEl = document.getElementById('shellInput');
const tickLbl = document.getElementById('tickLbl');
const rrLbl = document.getElementById('rrLbl');

/* ======================= Utilities ======================= */
const q = sel => document.querySelector(sel);
const tbody = sel => document.querySelector(sel+' tbody');
const htmlEsc = s => String(s).replace(/[<>&]/g,m=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[m]));
function printLine(s=''){ termOut.innerHTML += htmlEsc(String(s)) + '\n'; termOut.scrollTop = termOut.scrollHeight; }
function repr(x){ return typeof x==='string' ? `"${x}"` : String(x); }

/* ======================= Scheduler (with optional RR) ======================= */
function scheduleOneTick(){
  state.tick++;
  tickLbl.textContent = state.tick;

  // Wake DELAY tasks
  for(const t of state.tasks){
    if(t.state===TaskState.DELAY && state.tick>=t.wakeAt){
      t.state=TaskState.READY; t.info='delay done';
    }
  }
  // Fire watchdogs
  for(const wd of state.wds){
    if(wd.active && state.tick>=wd.expiresAt){
      wd.active=false;
      printLine(`wdog ${wd.id} fired -> ${wd.handler}(${repr(wd.arg)})`);
      if(wd.handler==='print'){ printLine(`[wd] ${wd.arg ?? ''}`); }
      else if(wd.handler==='spDemo'){ shell_sp(['demoLoop','10','5']); }
    }
  }

  // Pick READY tasks; lowest prio first
  const ready = state.tasks.filter(t=>t.state===TaskState.READY);
  if(ready.length===0){ renderAll(); return; }
  ready.sort((a,b)=>a.prio-b.prio || a.id-b.id);

  // If RR enabled, rotate among same-prio tasks using rrCursor
  let chosen = ready[0];
  if(state.rr){
    const topPrio = ready[0].prio;
    const same = ready.filter(t=>t.prio===topPrio);
    if(same.length>1){
      const cur = state.rrCursor[topPrio] ?? 0;
      chosen = same[cur % same.length];
    }
  }

  // Run one "step"
  chosen.state = TaskState.RUNNING;
  const beforeInfo = chosen.info;
  const res = chosen.step(chosen);

  // Interpret cooperative result
  if(!res || res.type==='yield'){
    chosen.state=TaskState.READY; chosen.info='yield';
    // Advance RR cursor only if task remained READY
    if(state.rr){ state.rrCursor[chosen.prio] = ((state.rrCursor[chosen.prio] ?? 0) + 1); }
  } else if(res.type==='delay'){
    chosen.state=TaskState.DELAY; chosen.wakeAt = state.tick + (res.ticks||1);
    chosen.info=`delay ${res.ticks||1}`;
  } else if(res.type==='pend'){
    chosen.state=TaskState.PENDED; chosen.wait = res.wait;
    if(res.wait.kind==='sem'){ const s=findSem(res.wait.id); if(s) s.pendQ.push(chosen.id); chosen.info=`pend sem ${res.wait.id}`; }
    else if(res.wait.kind==='mqRecv'){ const mq=findMq(res.wait.id); if(mq) mq.pendRecv.push(chosen.id); chosen.info=`pend mq ${res.wait.id}`; }
  } else if(res.type==='done'){
    chosen.state=TaskState.DEAD; chosen.info='exit';
  }
  renderAll();
}

function startClock(){
  if(state.running) return;
  state.running=true;
  const hz = Math.max(1, Math.min(1000, Number(q('#hz').value)||10));
  const period = 1000/hz;
  state.timer = setInterval(scheduleOneTick, period);
}
function pauseClock(){ state.running=false; clearInterval(state.timer); state.timer=null; }

/* ======================= Kernel Primitives ======================= */
function newTask(name, prio, stepFn){
  const t = { id: state.nextTid++, name, prio, state: TaskState.READY, pc: 0, step: stepFn, info:'' };
  state.tasks.push(t);
  return t.id;
}
function findTask(id){ return state.tasks.find(t=>t.id===Number(id)); }
function killTask(id){ const t=findTask(id); if(!t) return false; t.state=TaskState.DEAD; t.info='killed'; return true; }

/* ----- Semaphores ----- */
function semCreate(type='bin', init=1){
  type = (type==='count' || type==='counting')?'count':'bin';
  const s = { id: state.nextSid++, type, count: Math.max(0,Number(init)||0), pendQ:[] };
  if(type==='bin') s.count = (s.count>0)?1:0; // cap to 1
  state.sems.push(s); return s.id;
}
function findSem(id){ return state.sems.find(s=>s.id===Number(id)); }
function semGive(id){
  const s=findSem(id); if(!s) return 'no such sem';
  if(s.pendQ.length>0){
    const tid = s.pendQ.shift();
    const t = findTask(tid);
    if(t && t.state===TaskState.PENDED && t.wait?.kind==='sem' && t.wait.id===s.id){
      t.state=TaskState.READY; t.wait=null; t.info='sem acquired';
    }
  } else {
    if(s.type==='bin'){ s.count = 1; } else { s.count++; }
  }
  return 'OK';
}
function semTake(id){
  const s=findSem(id); if(!s) return {type:'yield'};
  if(s.count>0){ s.count--; return {type:'yield'}; }
  return { type:'pend', wait:{kind:'sem', id:s.id} };
}

/* ----- Message Queues ----- */
function msgQCreate(depth=8){
  const mq = { id: state.nextQid++, depth:Number(depth)||8, buf:[], pendRecv:[] };
  state.mqs.push(mq); return mq.id;
}
function findMq(id){ return state.mqs.find(q=>q.id===Number(id)); }
function msgQSend(id, msg){
  const mq=findMq(id); if(!mq) return 'no such q';
  if(mq.pendRecv.length>0){
    const tid = mq.pendRecv.shift();
    const t = findTask(tid);
    if(t && t.state===TaskState.PENDED && t.wait?.kind==='mqRecv' && t.wait.id===mq.id){
      t.lastMsg = msg; t.state=TaskState.READY; t.wait=null; t.info='msg recv';
      return 'OK*';
    }
  }
  if(mq.buf.length < mq.depth){ mq.buf.push(msg); return 'OK'; }
  return 'FULL';
}
function msgQReceive(id){
  const mq=findMq(id); if(!mq) return {type:'yield'};
  if(mq.buf.length>0){ const msg = mq.buf.shift(); this.lastMsg = msg; return { type:'yield' }; }
  return { type:'pend', wait:{kind:'mqRecv', id:mq.id} };
}

/* ----- Watchdogs ----- */
function wdStart(ticks, handler='print', arg){
  const wd = { id: state.nextWid++, expiresAt: state.tick + Math.max(1,Number(ticks)||1), active:true, handler, arg };
  state.wds.push(wd); return wd.id;
}
function wdCancel(id){ const wd = state.wds.find(w=>w.id===Number(id)); if(!wd) return false; wd.active=false; return true; }

/* ======================= Built-in Task Functions ======================= */
const Builtins = {
  demoLoop: (iters=10, delay=5) => { iters=+iters||10; delay=+delay||5; let i=0; return t=>{ if(i>=iters) return {type:'done'}; printLine(`[${t.name}] tick=${state.tick} step=${i}`); i++; return {type:'delay', ticks:delay}; }; },
  counter: (to=20) => { to=+to||20; let i=0; return t=>{ if(i>=to) return {type:'done'}; printLine(`[${t.name}] ${i}`); i++; return {type:'yield'}; }; },
  semWaiter: (sid) => { sid=+sid||1; let got=0; return function(t){ if(!got){ const r=semTake(sid); if(r.type==='pend') return r; printLine(`[${t.name}] took sem ${sid}`); got=1; return {type:'delay', ticks:5}; } else { printLine(`[${t.name}] releasing sem ${sid}`); semGive(sid); return {type:'done'}; } }; },
  mqRecv: (qid) => { qid=+qid||1; return function(t){ const r = msgQReceive.call(t,qid); if(r.type==='pend') return r; printLine(`[${t.name}] recv: ${repr(t.lastMsg)}`); t.lastMsg=null; return {type:'yield'}; }; },
  mqSend: (qid,msg='hello',cnt=5,delay=3) => { qid=+qid||1; cnt=+cnt||5; delay=+delay||3; let i=0; return t=>{ if(i>=cnt) return {type:'done'}; const status = msgQSend(qid, `${msg}#${i}`); printLine(`[${t.name}] send -> Q${qid} (${status})`); i++; return {type:'delay', ticks:delay}; }; },
};

/* ======================= Shell Helpers ======================= */
const history = { buf:[], idx:-1 };
function helpText(){
  return [
    'Commands:',
    '  version                                 show version',
    '  help                                    this help',
    '  i [tid]                                 task info (all or one)',
    '  sp <func>[,<arg>...] [-p prio]          spawn task (demoLoop, counter, semWaiter, mqRecv, mqSend)',
    '  td <tid>                                task delete',
    '  ts <tid>,<prio>                         set task priority',
    '  taskDelay <tid>,<ticks>                 delay a task (block in DELAY)',
    '  rr on|off                               enable/disable round-robin among same prio',
    '  rrShow                                  show RR status/cursors',
    '  semCreate [bin|count] [init]            create semaphore',
    '  semGive <sid>                           give semaphore',
    '  semShow                                 list semaphores',
    '  msgQCreate [depth]                      create message queue',
    '  msgQSend <qid>,<msg>                    send message (string allowed)',
    '  msgQShow                                list message queues',
    '  wdStart <ticks>,<handler>,[arg]         start watchdog (handlers: print, spDemo)',
    '  wdCancel <wid>                          cancel watchdog',
    '  memShow                                 show simple system stats',
    '  netShow                                 show dummy network interfaces',
    '  tickAnnounce [n]                        advance n ticks quickly',
    'Examples:',
    '  rr on; sp demoLoop, 10, 2 -p 100; sp demoLoop, 10, 2 -p 100; i',
    '  semCreate bin 0; sp semWaiter, 1; semGive 1',
    '  msgQCreate 4; sp mqRecv, 1; sp mqSend, 1, "hi", 3, 2',
  ].join('\n');
}
// split while keeping quoted strings
function parseArgs(line){
  const parts=[]; let cur='', inQ=false, qch='"';
  for(let i=0;i<line.length;i++){
    const c=line[i];
    if(inQ){ if(c===qch){ inQ=false; } else { cur+=c; } continue; }
    if(c==='"'||c=="'"){ inQ=true; qch=c; continue; }
    if(c===','||c===' '||c==='\t'){ if(cur){ parts.push(cur); cur=''; } continue; }
    cur+=c;
  }
  if(cur) parts.push(cur);
  return parts.filter(Boolean);
}

/* ======================= Shell Commands ======================= */
function shell_version(){ printLine('VxWorks mimic 0.2 (browser)'); }
function shell_i(args){
  if(args.length===0){
    const rows = state.tasks.map(t=>`${t.id}\t${t.name}\tprio=${t.prio}\t${t.state}\tpc=${t.pc}\t${t.info||''}`);
    printLine(rows.length? rows.join('\n') : '(no tasks)');
  } else {
    const t=findTask(args[0]); if(!t){ printLine('no such task'); return; }
    printLine(JSON.stringify(t,null,2));
  }
}
function shell_sp(args){
  let prio = 100;
  const at = args.findIndex(a=>a==='-p'||a==='-P');
  if(at>=0 && args[at+1]!=null){ prio = Number(args[at+1])||100; args.splice(at,2); }
  const funcName = args.shift();
  if(!funcName){ printLine('usage: sp <func> [args...] [-p prio]'); return; }
  const fn = Builtins[funcName];
  if(!fn){ printLine(`unknown func: ${funcName}`); return; }
  const step = fn(...args);
  const tid = newTask(`${funcName}`, prio, step);
  printLine(`task ${tid} spawned (${funcName})`);
}
function shell_td(args){ if(!args[0]) return printLine('usage: td <tid>'); printLine(killTask(args[0])?'killed':'no such task'); }
function shell_ts(args){
  if(args.length<2){ printLine('usage: ts <tid>,<prio>'); return; }
  const t=findTask(args[0]); if(!t){ printLine('no such task'); return; }
  t.prio = Number(args[1])||t.prio; printLine('OK');
}
function shell_taskDelay(args){
  if(args.length<2){ printLine('usage: taskDelay <tid>,<ticks>'); return; }
  const t=findTask(args[0]); const ticks=Number(args[1])||1;
  if(!t){ printLine('no such task'); return; }
  if(t.state===TaskState.DEAD){ printLine('task is DEAD'); return; }
  t.state=TaskState.DELAY; t.wakeAt = state.tick + ticks; t.info=`delay ${ticks}`;
  printLine('OK');
}
function shell_rr(args){
  const onoff = (args[0]||'').toLowerCase();
  if(onoff==='on'){ state.rr=true; rrLbl.textContent='on'; printLine('RR enabled'); }
  else if(onoff==='off'){ state.rr=false; rrLbl.textContent='off'; printLine('RR disabled'); }
  else printLine('usage: rr on|off');
}
function shell_rrShow(){ printLine(`RR=${state.rr?'on':'off'} cursors=${JSON.stringify(state.rrCursor)}`); }

function shell_semCreate(args){
  const type=(args[0]||'bin'); const init=args[1]|| (type==='bin'?1:0);
  const sid = semCreate(type, init); printLine(`sem ${sid} created (${type}, init=${init})`);
}
function shell_semGive(args){ if(!args[0]) return printLine('usage: semGive <sid>'); printLine(semGive(args[0])); }
function shell_semShow(){
  if(!state.sems.length) return printLine('(no semaphores)');
  for(const s of state.sems){ printLine(`S${s.id}\t${s.type}\tcount=${s.count}\tpend=[${s.pendQ.join(',')}]`); }
}
function shell_msgQCreate(args){
  const depth = args[0]||8; const qid = msgQCreate(depth); printLine(`msgQ ${qid} created (depth ${depth})`);
}
function shell_msgQSend(args){
  if(!args[0]) return printLine('usage: msgQSend <qid>,<msg>');
  const qid=args[0]; const msg = (args[1]!==undefined? args.slice(1).join(' ') : '');
  printLine(msgQSend(qid, msg));
}
function shell_msgQShow(){
  if(!state.mqs.length) return printLine('(no msgQs)');
  for(const q of state.mqs){ printLine(`Q${q.id}\tdepth=${q.depth}\tlen=${q.buf.length}\tpendRecv=[${q.pendRecv.join(', ')}]`); }
}
function shell_wdStart(args){
  if(!args[0]) return printLine('usage: wdStart <ticks>,<handler>,[arg]');
  const ticks=args[0]; const handler=args[1]||'print'; const arg=args[2];
  const id = wdStart(ticks, handler, arg); printLine(`wd ${id} started, expires@${state.tick+Number(ticks||1)}`);
}
function shell_wdCancel(args){ if(!args[0]) return printLine('usage: wdCancel <wid>'); printLine(wdCancel(args[0])?'OK':'no such wd'); }
function shell_memShow(){
  const stats = {
    tick: state.tick,
    tasks_total: state.tasks.length,
    tasks_ready: state.tasks.filter(t=>t.state==='READY').length,
    tasks_pended: state.tasks.filter(t=>t.state==='PENDED').length,
    tasks_delay: state.tasks.filter(t=>t.state==='DELAY').length,
    tasks_dead: state.tasks.filter(t=>t.state==='DEAD').length,
    sems: state.sems.length,
    msgqs: state.mqs.length,
    wdogs: state.wds.filter(w=>w.active).length,
  };
  printLine(JSON.stringify(stats, null, 2));
}
function shell_netShow(){
  const lines = [
    'lo0      UP    MTU 65535  inet 127.0.0.1/8   RX 0  TX 0',
    'ge0      DOWN  MTU 1500   inet 0.0.0.0/0     RX 0  TX 0',
    'vxb0     UP    MTU 9000   inet 10.0.0.123/24 RX 42 TX 42 (pretend)'
  ];
  printLine(lines.join('\n'));
}
function shell_tickAnnounce(args){ const n = Math.max(1, Number(args[0]||1)); for(let i=0;i<n;i++) scheduleOneTick(); }

/* ======================= Rendering ======================= */
function renderTasks(){
  const tb = tbody('#taskTable'); tb.innerHTML='';
  const rows = [...state.tasks].sort((a,b)=>a.prio-b.prio || a.id-b.id);
  for(const t of rows){
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>T${t.id}</td>
      <td>${htmlEsc(t.name)}</td>
      <td>${t.prio}</td>
      <td><span class="pill state-${t.state}">${t.state}</span></td>
      <td>${t.pc ?? 0}</td>
      <td class="tiny">${htmlEsc(t.info||'')}</td>
    `;
    tb.appendChild(tr);
  }
}
function renderSems(){
  const tb = tbody('#semTable'); tb.innerHTML='';
  for(const s of state.sems){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>S${s.id}</td><td>${s.type}</td><td>${s.count}</td><td class="tiny">[${s.pendQ.join(', ')}]</td>`;
    tb.appendChild(tr);
  }
}
function renderMqs(){
  const tb = tbody('#mqTable'); tb.innerHTML='';
  for(const q of state.mqs){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>Q${q.id}</td><td>${q.depth}</td><td>${q.buf.length}</td><td class="tiny">[${q.pendRecv.join(', ')}]</td>`;
    tb.appendChild(tr);
  }
}
function renderWds(){
  const tb = tbody('#wdTable'); tb.innerHTML='';
  for(const w of state.wds){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>W${w.id}</td><td>${w.expiresAt}</td><td>${w.active? 'yes':'no'}</td><td>${w.handler}${w.arg!==undefined? '('+htmlEsc(String(w.arg))+')':''}</td>`;
    tb.appendChild(tr);
  }
}
function renderAll(){ renderTasks(); renderSems(); renderMqs(); renderWds(); }

/* ======================= Wiring ======================= */
document.getElementById('runBtn').addEventListener('click', startClock);
document.getElementById('pauseBtn').addEventListener('click', pauseClock);
document.getElementById('stepTickBtn').addEventListener('click', scheduleOneTick);

inputEl.addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){
    const line = inputEl.value.trim(); if(!line) return;
    history.buf.push(line); history.idx = history.buf.length;
    printLine('-> ' + line);
    const [cmd, ...rest] = parseArgs(line);
    switch((cmd||'').toLowerCase()){
      case 'help': printLine(helpText()); break;
      case 'version': shell_version(); break;
      case 'i': shell_i(rest); break;
      case 'sp': shell_sp(rest); break;
      case 'td': shell_td(rest); break;
      case 'ts': shell_ts(rest); break;
      case 'taskdelay': shell_taskDelay(rest); break;
      case 'rr': shell_rr(rest); break;
      case 'rrshow': shell_rrShow(); break;
      case 'semcreate': shell_semCreate(rest); break;
      case 'semgive': shell_semGive(rest); break;
      case 'semshow': shell_semShow(); break;
      case 'msgqcreate': shell_msgQCreate(rest); break;
      case 'msgqsend': shell_msgQSend(rest); break;
      case 'msgqshow': shell_msgQShow(); break;
      case 'wdstart': shell_wdStart(rest); break;
      case 'wdcancel': shell_wdCancel(rest); break;
      case 'memshow': shell_memShow(); break;
      case 'netshow': shell_netShow(); break;
      case 'tickannounce': shell_tickAnnounce(rest); break;
      default: printLine('unknown command (try "help")');
    }
    inputEl.value='';
  } else if(e.key==='ArrowUp'){
    if(history.idx>0){ history.idx--; inputEl.value = history.buf[history.idx]||''; e.preventDefault(); }
  } else if(e.key==='ArrowDown'){
    if(history.idx < history.buf.length){ history.idx++; inputEl.value = history.buf[history.idx]||''; e.preventDefault(); }
  }
});

/* ======================= Boot Banner ======================= */
function boot(){
  printLine('VxWorks mimic 0.2');
  printLine('CPU: pretend 68k • Scheduler: prio + optional RR • Sem/MsgQ/WD supported');
  printLine('Type "help" to list commands');
  renderAll();
}
boot();
</script>
</body>
</html>
